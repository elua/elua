/**
 * @file sltha.c
 * @date 2015-12-15
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 */
/**
 * @cond
 ***********************************************************************************************************************
 * FATFS v4.0.8 Provides the support for standard FATFS library
 *
 * Copyright (c) 2015, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-12-15:
 *     - Initial version<br>
 *
 * @endcond
 *
 */
#include "sltha.h"

#if (FATFS_STANDARDLIBRARY == 1U)
/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include <stdio.h>
/***********************************************************************************************************************
	* MACROS
 **********************************************************************************************************************/
/** File Handle array to store the file information  */
SLTHA_FILEHANDLE_t FileHandle[MAX_OPEN_FILES] = {{0}};

#if defined(__GNUC__) || defined(__TASKING__)

DWORD ErrorCodes[20] = {
         SLTHA_SUCCESS,
         (SLTHA_ERROR),  // FR_DISK_ERR,            /* (1) A hard error occurred in the low level disk I/O layer */
         (SLTHA_ERROR),  // FR_INT_ERR,	            /* (2) Assertion failed */
         EIO,            // FR_NOT_READY,           /* (3) The physical drive cannot work */
         ENOENT,         // FR_NO_FILE,	            /* (4) Could not find the file */
         ENOENT,         // FR_NO_PATH,	            /* (5) Could not find the path */
         EINVAL,         // FR_INVALID_NAME,        /* (6) The path name format is invalid */
         EACCES,         // FR_DENIED,				/* (7) Access denied due to prohibited access or directory full */
         EEXIST,         // FR_EXIST,				/* (8) Access denied due to prohibited access */
         EBADF,          // FR_INVALID_OBJECT,		/* (9) The file/directory object is invalid */
         EACCES,         // FR_WRITE_PROTECTED,		/* (10) The physical drive is write protected */
         ENODEV,         // FR_INVALID_DRIVE,		/* (11) The logical drive number is invalid */
         EIO,            // FR_NOT_ENABLED,			/* (12) The volume has no work area */
         EIO,            // FR_NO_FILESYSTEM,		/* (13) There is no valid FAT volume */
         (SLTHA_ERROR),  // FR_MKFS_ABORTED,		/* (14) The f_mkfs() aborted due to any parameter error */
         (SLTHA_ERROR),  // FR_TIMEOUT,				/* (15) Could not get a grant to access the volume within defined period */
         (SLTHA_ERROR),  // FR_LOCKED,				/* (16) The operation is rejected according to the file sharing policy */
         (SLTHA_ERROR),  // FR_NOT_ENOUGH_CORE,		/* (17) LFN working buffer could not be allocated */
         (SLTHA_ERROR),  // FR_TOO_MANY_OPEN_FILES,	/* (18) Number of open files > _FS_LOCK */
         (SLTHA_ERROR)   // FR_INVALID_PARAMETER	/* (19) Given parameter is invalid */
};
#elif defined __CC_ARM
DWORD ErrorCodes[20] = { EINVAL };
#elif defined __ICCARM__
DWORD ErrorCodes[20] = {_LLIO_ERROR};
#endif
/***********************************************************************************************************************
 * LOCAL DATA
 **********************************************************************************************************************/
#if _FS_REENTRANT
/** Mutex Defined to protect the Slot Allocation Table in multi-task environment. */
osMutexDef(SlotHandle);
osMutexId SlotProtectionId;
#endif

#ifdef __CC_ARM
/** Standard IO device name defines. */
const char __stdin_name[]  = "STDIN";
const char __stdout_name[] = "STDOUT";
const char __stderr_name[] = "STDERR";
#endif
/***********************************************************************************************************************
 * LOCAL ROUTINES
 **********************************************************************************************************************/
static int  SLTHA_lFindAvailableSlot(int filedesc);
static time_t SLTHA_lTimeFormat(const FILINFO *fatfsinfoptr);

static void SLTHA_lFatInfoToStatus(struct stat *filestatusptr, const FILINFO *fatfsinfoptr);
#if !_FS_REENTRANT
static int SLTHA_lParamValidate(const char *path, int *flagptr, uint8_t *fatfsflagptr, int *slotnumptr);
#endif
#ifdef  __TASKING__
static _err_t SLTHA_lSetFlagsAccessModes(_open_flags_t *flagsptr, BYTE *fatfsflagptr);
#else
static int SLTHA_lSetFlagsAccessModes(int *flagsptr, BYTE *fatfsflagptr);
#endif

/**********************************************************************************************************************
* API IMPLEMENTATION
**********************************************************************************************************************/
/*
 *  Function to Initialize all the local variables of Standard Librarry App
 */
void SLTHA_Init()
{
  int slot;
/* Initialize Handle in the FileHandle Structure to -1*/
  for (slot=0; slot<MAX_OPEN_FILES; slot++)
  {
    FileHandle[slot].Fd = -1;
  }
/* Preserve the 0th, 1th and 2nd File Handles for Standard I/O and Error.*/
  FileHandle[0].Fd = STDIN_HANDLE;
  FileHandle[1].Fd = STDOUT_HANDLE;
  FileHandle[2].Fd = STDERR_HANDLE;
#if _FS_REENTRANT
  SlotProtectionId = osMutexCreate(osMutex(SlotHandle));
#endif
}

/*
 * Function to find whether the file is already opened and also assign a slot
 * for any new file to open.
 */
int SLTHA_lFindAvailableSlot(int filedesc)
{
  static int slot = 0;
  static int lastallocfilehandle = -1;
  int localslot = 0;
#if _FS_REENTRANT
  osStatus SemStatus;
  /* Slot allocation is protected by Mutex for re-entrancy */
  SemStatus = osMutexWait(SlotProtectionId,  osWaitForever);
  if (osOK == SemStatus)
  {
#endif
    /* Check if the File handle is the last allocated one */
    if ((filedesc != -1)  && (filedesc == lastallocfilehandle))
    {
      /* Local copy of the allocated slot. */
      localslot = slot;
    }
    else
    {
      /* Check the FileHandle array to find the match for the File Handle*/
      for (slot=0; slot<MAX_OPEN_FILES; slot++ )
      {
        if (FileHandle[slot].Fd == filedesc)
        {
          if (filedesc == SLTHA_EMPTY_SLOT)
          {
            /* Set the allocated slot value from free to allocated state so that the other tasks cannot use it.*/
            FileHandle[slot].Fd = SLTHA_ALLOCATED_NOT_IN_USE;
          } /* End of "if (FileDesc == SLTHA_EMPTY_SLOT )"*/
          break;
        }/* End of  " if (FileHandle[Slot].Fd == FileDesc)"*/
      }
    }
      /* Local copy of the allocated slot. */
      localslot = slot;
      /* Save the last Allocated File Handle.*/
      lastallocfilehandle = filedesc;
#if _FS_REENTRANT
  }
  /* Release the mutex */
  if (SemStatus == osOK)
  {
    SemStatus =  osMutexRelease(SlotProtectionId);
  }
#endif

  return (localslot);
}

#if (_FS_MINIMIZE == 0U)
#if defined (__GNUC__) || defined ( __TASKING__)
/*
 * This function converts the time format
 */
static time_t SLTHA_lTimeFormat(const FILINFO *FatFsInfoPtr)
{
  struct tm TimeStruct;
  TimeStruct.tm_sec  = (FatFsInfoPtr->ftime & 0x001fUL) << 1UL;
  TimeStruct.tm_min  = (FatFsInfoPtr->ftime & 0x07e0UL) >> 5UL;
  TimeStruct.tm_hour = (FatFsInfoPtr->ftime & 0xf800UL) >> 11UL;
  TimeStruct.tm_mday = (FatFsInfoPtr->fdate & 0x001fUL);
  TimeStruct.tm_mon  = ((FatFsInfoPtr->fdate & 0x01e0UL) >> 5UL) - 1UL;
  TimeStruct.tm_year = ((FatFsInfoPtr->fdate & 0xfe00UL) >> 9UL) + 80UL;
  TimeStruct.tm_isdst = 0;
  return mktime(&TimeStruct);
}
#endif

/*
 *  Function to store the file information in the file status pointer
 */
#if defined (__GNUC__) || defined ( __TASKING__)
static void SLTHA_lFatInfoToStatus(struct stat *FileStatusPtr, const FILINFO *FatFsInfoPtr)
{
  memset(FileStatusPtr, 0, sizeof(stat));
  /*Populate the Argument Status Pointer with the Fat FS status Pointer*/
  FileStatusPtr->st_mode |= (FatFsInfoPtr->fattrib & AM_DIR) ? S_IFDIR : S_IFREG;
#if defined (__GNUC__)
  FileStatusPtr->st_mode |= (FatFsInfoPtr->fattrib & AM_RDO) ? ((S_IRWXU & ~S_IWUSR) |
                                                                (S_IRWXG & ~S_IWGRP) |
                                                                (S_IRWXO & ~S_IWOTH)) : (S_IRWXU | S_IRWXG | S_IRWXO);
#else
  FileStatusPtr->st_mode |= (FatFsInfoPtr->fattrib & AM_RDO) ?  (~_S_IWRITE) : (_S_IWRITE);
#endif
  FileStatusPtr->st_size = FatFsInfoPtr->fsize;
  FileStatusPtr->st_ctime = SLTHA_lTimeFormat(FatFsInfoPtr);
  FileStatusPtr->st_mtime = FileStatusPtr->st_ctime;
  FileStatusPtr->st_atime = FileStatusPtr->st_ctime;
#if defined (__GNUC__)
  FileStatusPtr->st_blksize = 512;
#endif
}
#endif
#endif

/*
 * This function set the file access modes.
 */
#ifdef  __TASKING__
  static _err_t SLTHA_lSetFlagsAccessModes(_open_flags_t *FlagsPtr, BYTE *FatFsFlagPtr)
#else
  static int SLTHA_lSetFlagsAccessModes(int *FlagsPtr, BYTE *FatFsFlagPtr)
#endif
{
  bool readonlyflag = false;
#ifdef  __TASKING__
  _err_t status = SLTHA_SUCCESS;
#else
  int status = SLTHA_SUCCESS;
#endif
#if defined(__GNUC__) || defined( __TASKING__) || defined(__ICCARM__ )
   /*  Append and Truncate flags cannot be set together */
  if (*FlagsPtr & SLTHA_APPEND)
  {
    *FlagsPtr &= ~SLTHA_TRUNC ;
  }
    /* Create & Truncate & Access mode is Write */
  if ( ((*FlagsPtr & (SLTHA_CREAT | SLTHA_TRUNC)) == (SLTHA_CREAT | SLTHA_TRUNC)) &&
                                                     (*FlagsPtr & (SLTHA_RDWR | SLTHA_WRONLY)))
  {
#if _FS_READONLY
    readonlyflag = true;
    status = SLTHA_ERROR;
#else
    *FatFsFlagPtr = FA_CREATE_ALWAYS;
#endif
  }
  /* O_EXCL  When used with O_CREAT, if the file already exists it is an error and the open() will fail. */
  else if ((*FlagsPtr & (SLTHA_CREAT | SLTHA_EXCL)) == (SLTHA_CREAT | SLTHA_EXCL))
  {
    *FatFsFlagPtr = FA_OPEN_EXISTING;
  }
  /* Only create flag is set, opens the file if exist else creates a new file */
  else if ((*FlagsPtr & SLTHA_CREAT) == SLTHA_CREAT)
  {
#if _FS_READONLY
    ReadOnlyFlag = true;
    Status = SLTHA_ERROR;
#else
    *FatFsFlagPtr = FA_OPEN_ALWAYS;
#endif
  }
  /* Opens the file if any of the read, write or r/w flags are only set*/
  else if ((*FlagsPtr == SLTHA_RDONLY) || (*FlagsPtr == SLTHA_WRONLY) || (*FlagsPtr == SLTHA_RDWR))
  {
    *FatFsFlagPtr = FA_OPEN_EXISTING;
  }
  else
  {
#if defined(__GNUC__) || defined( __TASKING__)
    errno = EINVAL;
#elif defined( __ICCARM__)
    errno = _LLIO_ERROR;
#endif
    readonlyflag = true;
    status = SLTHA_ERROR;
  }
#endif
  /* Check the access mode */
  if (readonlyflag == false )
  {
#if defined(__GNUC__) || defined( __TASKING__) || defined( __ICCARM__ )
    if ((*FlagsPtr & SLTHA_RDWRMASK) == SLTHA_RDONLY)
#elif defined __CC_ARM
    if (*FlagsPtr &  SLTHA_RDONLY)
#endif
    {
      *FatFsFlagPtr |= FA_READ;
    }
#if defined(__GNUC__) || defined( __TASKING__) || defined( __ICCARM__ )
    else if ((*FlagsPtr & SLTHA_RDWRMASK) == SLTHA_WRONLY)
#elif defined __CC_ARM
    else if (*FlagsPtr &  SLTHA_WRONLY)
#endif
    {
#if _FS_READONLY
      Status = SLTHA_ERROR;
#else
      *FatFsFlagPtr |= FA_WRITE;
#endif
    }
#if defined(__GNUC__) || defined( __TASKING__) || defined( __ICCARM__ )
    else if ((*FlagsPtr & SLTHA_RDWRMASK) == SLTHA_RDWR)
#elif defined __CC_ARM
    else if (*FlagsPtr & SLTHA_RDWR)
#endif
    {
#if _FS_READONLY
      status = SLTHA_ERROR;
#else
      *FatFsFlagPtr |= (FA_READ | FA_WRITE);
#endif
    }
    else
    {
#if defined(__GNUC__) || defined( __TASKING__)
      errno = EINVAL;
#elif defined  __ICCARM__
      errno = _LLIO_ERROR;
#elif defined __CC_ARM
      errno = EINVAL;
#endif
      status = (int)SLTHA_ERROR;
    }
  } /* End of " if ( ReadOnlyFlag == FALSE )"*/
  return (status);
}

#if !_FS_REENTRANT
int SLTHA_lParamValidate(const char *Path, int *FlagPtr, uint8_t *FatFsFlagPtr, int *SlotNumPtr)
{
#ifdef  __TASKING__
  _err_t status = SLTHA_ERROR;
#else
  int status = (int)SLTHA_ERROR;
#endif
  int pathlen = 0;
  int slotnumber;
  /*  Check free slot is available to open the file. If not then return error. */
  slotnumber = SLTHA_lFindAvailableSlot(SLTHA_EMPTY_SLOT);
  if (slotnumber == MAX_OPEN_FILES)
  {
#if defined(__GNUC__) || defined( __TASKING__)
    errno = ENFILE;
#elif defined __CC_ARM
    errno =  EINVAL;
#elif defined  __ICCARM__
    errno = _LLIO_ERROR;
#endif
  }/* End of "if (SlotNumber == MAX_OPEN_FILES)"*/
  else
  {
    *SlotNumPtr = slotnumber;
    /* Check the file path name should not exceed the maximum value*/
    pathlen = strlen(Path);
    if (!(pathlen > FILENAME_MAX ))
    {
      /* Check and Set Flags Accordingly */
      status = SLTHA_lSetFlagsAccessModes(FlagPtr, FatFsFlagPtr);
      if (status != SLTHA_SUCCESS)
      {
#if defined(__GNUC__) || defined( __TASKING__) || defined (__CC_ARM)
        errno = EINVAL;
#elif defined  __ICCARM__
        errno = _LLIO_ERROR;
#endif
      } /* End of "if ( Status != SLTHA_SUCCESS))"*/
      else
      {
        /* Allocate memory to store the file path name.*/
        FileHandle[slotnumber].FilePath = (char *)malloc(pathlen + 1);
        if (FileHandle[slotnumber].FilePath  == NULL)
        {
          status = (int)SLTHA_ERROR;
        }
        else
        {
          /* Store the file path name */
          strcpy(FileHandle[slotnumber].FilePath, Path);
#if defined(__GNUC__) || defined( __TASKING__)
          errno = EIO;
#elif defined __CC_ARM
          errno =  EINVAL;
#elif  __ICCARM__
          errno = _LLIO_ERROR;
#endif
          /* If File Pointer is NULL, then allocate the memory to open a file */
          if (FileHandle[slotnumber].FatFsPtr == NULL)
          {
            FileHandle[slotnumber].FatFsPtr = (FIL *)calloc(1, sizeof(FIL));
            if (FileHandle[slotnumber].FatFsPtr == NULL)
            {
              status = (int)SLTHA_ERROR;
            } /* End of "if (FileHandle[SlotNumber].FatFsPtr == NULL))"*/
          } /* End of "if (FileHandle[SlotNumber].FatFsPtr == NULL)"*/
        } /* End of "if( FileHandle[SlotNumber].FilePath  == NULL )"*/
      } /* End of "if( Status != SLTHA_SUCCESS)" */
    }/*End of " if (!(PathLen > FILENAME_MAX ))"*/
  } /* End of "if (SlotNumber == MAX_OPEN_FILES)"*/
  return (status);
}

/**
 * @endcond
 */

/******************************************************************************
**                      Public Function Definitions                           **
*******************************************************************************/
/*
 * This function opens the file specified by the Path in the mode
 */
SLTHA_Open()
{
#ifdef  __TASKING__
  _err_t status;
  _err_t filedesc = -1;
#else
  int status;
  int filedesc = -1;
#endif
  int slotnumber;
  uint8_t FatFsFlags = FA_OPEN_EXISTING;
  FRESULT result;
  /* Find slot and validate the access modes.*/
  status  = SLTHA_lParamValidate((const char *)Path, &Flags, &FatFsFlags, &slotnumber);
  if (status == SLTHA_SUCCESS)
  {
/* Call the f_open function */
    result = f_open(FileHandle[slotnumber].FatFsPtr, Path, FatFsFlags);
    if (result != FR_OK)
    {
      errno = ErrorCodes[result];
    } /* End of "if( Result != FR_OK)"*/
    else
    {
      filedesc = slotnumber + MONITOR_FATFS;
      FileHandle[slotnumber].Flags = Flags;
      FileHandle[slotnumber].CurrentPos = 0;
      /* if Append flag set, Get the end position by using FatFS lseek function */
      if (Flags & SLTHA_APPEND)
      {
#if (_FS_MINIMIZE == 3U)
        Result = FR_DENIED;
#else
        result = f_lseek(FileHandle[slotnumber].FatFsPtr, FileHandle[slotnumber].FatFsPtr->fsize);
#endif
        if (result != FR_OK)
        {
          filedesc = -1;
        }/* End of "if( Result != FR_OK)"*/
        else
        {
          FileHandle[slotnumber].CurrentPos = (int)FileHandle[slotnumber].FatFsPtr->fptr;
        }
      } /* End of "if(Flags & SLTHA_APPEND)"*/
    }
  }
  /* Update the FD in the File Handle. */
  FileHandle[slotnumber].Fd = filedesc;
  status = filedesc;
/* Free the memory if File Handle is -1 and Valid FatFsPtr exists */
  if ((filedesc < 0) &&  (FileHandle[slotnumber].FatFsPtr != NULL))
  {
    free (FileHandle[slotnumber].FilePath);
    free (FileHandle [slotnumber].FatFsPtr);
    FileHandle[slotnumber].FilePath = NULL;
    FileHandle[slotnumber].FatFsPtr = NULL;
  } /* End of "if((FileDesc < 0) &&  FileHandle[SlotNumber].FatFsPtr )"*/
  return (status);
}

/*
 * This function closes the file specified by the File descriptor.
 */
SLTHA_Close()
{
#ifdef  __TASKING__
  _err_t status = SLTHA_ERROR;
#else
  int status = (int)SLTHA_ERROR;
#endif
  int slotnumber;
  FRESULT result;
  do
  {
    /* Find the Slot number */
    slotnumber = SLTHA_lFindAvailableSlot(Fd);
    if (slotnumber == MAX_OPEN_FILES)
    {
#if defined(__GNUC__) || defined( __TASKING__)
      errno = EBADF;
#elif defined __CC_ARM
      errno = EINVAL;
#elif defined  __ICCARM__
      errno = _LLIO_ERROR;
#endif
      break;
    }
/* Check FilePtr is not Null */
    if (FileHandle[slotnumber].FatFsPtr != NULL)
    {
      result = f_close(FileHandle[slotnumber].FatFsPtr);
      /* Set the handle in the file info structure to -1 */
      free (FileHandle[slotnumber].FilePath);
      free (FileHandle[slotnumber].FatFsPtr);
      FileHandle[slotnumber].FatFsPtr = NULL;
      if (result != FR_OK)
      {
        errno = ErrorCodes[result];
      }
      else
      {
        status = SLTHA_SUCCESS;
      }
    }
    /* free the occupied slot */
    FileHandle[slotnumber].Fd = -1;
  } while (0);
  return (status);
}

/*
 * This function reads specified bytes of data from the file.
 */
SLTHA_Read()
{
  int slotnumber;
  int bytesread = 0;
  int bytesunread = -1;
  FRESULT result;
  /* Find the Slot number occupied by the file to read from.*/
  slotnumber = SLTHA_lFindAvailableSlot(Fd);
/* Check If write only flag is set  or Max Files are opened.*/
  if ( (slotnumber == MAX_OPEN_FILES) || ((FileHandle[slotnumber].Flags & SLTHA_WRONLY) != 0))
  {
#if defined(__GNUC__) || defined( __TASKING__)
    errno = EBADF;
#elif defined __CC_ARM
    errno = EINVAL;
#elif defined __ICCARM__
    errno = _LLIO_ERROR;
#endif
    bytesread = -1;
  }
  else
  {
/* Switch as per the file descriptor.*/
    switch (Fd)
    {
      case STDIN_HANDLE:
           break;

      case STDOUT_HANDLE:
             break;

      case STDERR_HANDLE:
             break;

      default:
         if (FileHandle[slotnumber].FatFsPtr != NULL)
         {
           /* Call the Fat FS f_read function */
           result = f_read(FileHandle[slotnumber].FatFsPtr, BufferPtr, Length, (UINT *)&bytesread);
           if (result != FR_OK)
           {
             errno = ErrorCodes[result];
             bytesread = -1;
           }
           else
           {
             bytesunread = (int)Length - bytesread;
           }
         }/*End of "if (FileHandle[SlotNumber].FatFsPtr != NULL)"*/
         break;
      }
    if (bytesunread < 0)
    {
      bytesread = -1;
    }
    else
    {
      FileHandle[slotnumber].CurrentPos += ((int)Length - bytesunread);
    }
  }
  return (bytesread);
}

/*
 * This function writes Length bytes of data into the file specified.
 */
SLTHA_Write()
{
  int slotnumber;
  int byteswritten = 0;
  int bytesunwritten = -1;
#if (_FS_READONLY == 0U)
  FRESULT result;
#endif
  /* Find the Slot number occupied by the file to read from.*/
  slotnumber = SLTHA_lFindAvailableSlot(Fd);
  /* Check If read only flag is set or Max Files are opened. */
  if ( (slotnumber == MAX_OPEN_FILES) || ((FileHandle[slotnumber].Flags & SLTHA_RDONLY ) == 1))
  {
#if defined(__GNUC__) || defined( __TASKING__)
    errno = EBADF;
#elif defined  __CC_ARM
    errno = EINVAL;
#elif defined  __ICCARM__
    errno = _LLIO_ERROR;
#endif
  }
  else
  {
/* Switch as per the file descriptor.*/
    switch (Fd)
    {
      case STDIN_HANDLE:
           break;

      case STDOUT_HANDLE:
           break;

      case STDERR_HANDLE:
           break;
      default:
#if _FS_READONLY
        break;
#else
        if (FileHandle[slotnumber].FatFsPtr != NULL)
        {
          /* Call the Fat FS f_write function */
          result = f_write(FileHandle[slotnumber].FatFsPtr, BufferPtr, Length, (UINT *)&byteswritten);
          if (result != FR_OK)
          {
            errno = ErrorCodes[result];
          }
          else
          {
            bytesunwritten = (int)Length - byteswritten;
          }
        }
        break;
#endif
    } /* End of "switch case "*/
  }
  if ((bytesunwritten  == -1) || (bytesunwritten == (int)Length))
  {
    byteswritten = -1;
  }
  else
  {
    FileHandle[slotnumber].CurrentPos += ((int)Length - bytesunwritten);
  }
  return (byteswritten);
}

/*
 * This function Move file pointer of a file object specified by the
 * File Descriptor.
 */
SLTHA_Lseek()
{
  int fileoffset = -1;
#if (_FS_MINIMIZE != 3U)
  int slotnumber;
  FRESULT result;
#endif

#if (_FS_MINIMIZE != 3U)
  /* Find the Slot number occupied by the file to read from.*/
  slotnumber = SLTHA_lFindAvailableSlot(Fd);
  if ((slotnumber == MAX_OPEN_FILES) ||  (FileHandle[slotnumber].FatFsPtr == NULL))
  {
#if defined(__GNUC__) || defined( __TASKING__)
    errno = EBADF;
#elif defined __CC_ARM
    errno = EINVAL;
#elif defined  __ICCARM__
    errno = _LLIO_ERROR;
#endif
  }
  else
  {
#if defined(__GNUC__) || defined( __TASKING__) || defined( __ICCARM__ )
    /* Check Direction Mode */
    if (DirMode == SEEK_SET)
    {
      result = f_lseek(FileHandle[slotnumber].FatFsPtr, Offset);
    }
    else if (DirMode == SEEK_CUR)
    {
      result = f_lseek(FileHandle[slotnumber].FatFsPtr, FileHandle [slotnumber].FatFsPtr->fptr + Offset);
    }
    else if (DirMode == SEEK_END)
    {
      result = f_lseek(FileHandle[slotnumber].FatFsPtr, FileHandle [slotnumber].FatFsPtr->fsize + Offset);
    }
    else
    {
      result = FR_INVALID_PARAMETER;
    }
#elif __CC_ARM
    result = f_lseek(FileHandle[slotnumber].FatFsPtr, Offset);
#endif
    /* If Fat FS Function call returns Error*/
    if (result != FR_OK)
    {
      errno = ErrorCodes[result];
    }
    else
    {
      FileHandle[slotnumber].CurrentPos = (int)FileHandle[slotnumber].FatFsPtr->fptr;
      fileoffset = FileHandle[slotnumber].CurrentPos;
    }
  }
#endif
  return (fileoffset);
}

/*
 * This function Delete an existing file or directory.
 */
SLTHA_Remove()
{
  int status = (int)SLTHA_ERROR;
#if ((_FS_READONLY == 0U) && ( _FS_MINIMIZE == 0U))
  FRESULT result;
#endif
  do
  {
#if ((_FS_READONLY != 0U) || ( _FS_MINIMIZE != 0U))
    break;
#else
    /* Call the Fat FS unlink function */
    result = f_unlink(Path);
    if (result != FR_OK)
    {
      errno = ErrorCodes[result];
      break;
    }
    status = SLTHA_SUCCESS;
#endif
  } while (0);
  return (status);
}

/*
 * This function gets file status on basis of file descriptor passed.
 */

#if defined  (__GNUC__) || defined (  __TASKING__)
SLTHA_FileStatus()
{
  int status = SLTHA_ERROR;
#if (_FS_MINIMIZE == 0U)
  FILINFO FatFsInfoStruct = {0};
  FRESULT result;
  int slotnumber;
  do
  {
    if ((Fd >= STDIN_HANDLE ) && (Fd <= STDERR_HANDLE ))
    {
      FileStatusPtr->st_mode = S_IFCHR;
      status = SLTHA_SUCCESS;
      break;
    }
    /* Find the Slot number occupied by the file to read the status*/
    slotnumber = SLTHA_lFindAvailableSlot(Fd);
    /* Call the Fat FS Status function */
    result = f_stat(FileHandle[slotnumber].FilePath, &FatFsInfoStruct);
    if (result != FR_OK)
    {
      errno = ErrorCodes[result];
    }
    else
    {
      SLTHA_lFatInfoToStatus(FileStatusPtr,(const FILINFO*)&FatFsInfoStruct);
      status = SLTHA_SUCCESS;
    }
  } while (0);
#endif
  return (status);
}

/*
 * This function gets file status on basis of file path
 */
SLTHA_Status()
{
  int status = SLTHA_ERROR;
#if (_FS_MINIMIZE == 0U)
  FILINFO FatFsInfoStruct = {0};
  FRESULT result;
  do
  {
    /* Call the Fat FS Status function */
    result = f_stat(Path, &FatFsInfoStruct);
    if (result != FR_OK)
    {
      errno = ErrorCodes[result];
      break;
    }
    SLTHA_lFatInfoToStatus(FileStatusPtr,(const FILINFO*)&FatFsInfoStruct);
    status = SLTHA_SUCCESS;
  } while (0);
#endif
  return (status);
}
#endif

/*
 * This function rename/move a file or directory.
 */
SLTHA_Rename()
{
#if ((_FS_READONLY == 0U) && ( _FS_MINIMIZE == 0U))
  FRESULT result;
#endif
  int status = (int)SLTHA_ERROR;
  do
  {
#if ((_FS_READONLY != 0U) || ( _FS_MINIMIZE != 0U))
    break;
#else
    /* Call the Fat FS Status function */
    result = f_rename(Oldpath, Newpath);
    if (result != FR_OK)
    {
      errno = ErrorCodes[result];
    }
    else
    {
      status = SLTHA_SUCCESS;
    }
#endif
  } while (0);
  return (status);
}
#else
/*
 * This function opens the file specified by the Path in the mode
 */
SLTHA_Open()
{
#ifdef  __TASKING__
  _err_t status = SLTHA_ERROR;
  _err_t filedesc = -1;
#else
  int status = SLTHA_ERROR;
  int filedesc = -1;
#endif
  int  slotnumber;
  uint32_t pathlen = 0;
  BYTE FatFsFlags = FA_OPEN_EXISTING;
  FRESULT result;
  do
  {
/*  Check free slot is available to open the file. If not then return error. */
    slotnumber = SLTHA_lFindAvailableSlot(SLTHA_EMPTY_SLOT);
    if (slotnumber == MAX_OPEN_FILES)
    {
#if ((defined(__GNUC__) || defined( __TASKING__)) && _FS_REENTRANT)
      ReentPtr->_errno = ENFILE;
#elif defined __CC_ARM
      errno =  EINVAL;
#elif defined  __ICCARM__
      errno = _LLIO_ERROR;
#endif
      break;
    }/* End of "if (SlotNumber == MAX_OPEN_FILES)"*/
    /* Check the file path name should not exceed the maximum value*/
    pathlen = strlen(Path);
    if (pathlen > FILENAME_MAX)
    {
      break;
    }
/* Check and Set Flags Accordingly */
    status = SLTHA_lSetFlagsAccessModes(&Flags, &FatFsFlags);
    if (status != SLTHA_SUCCESS)
    {
#if defined(__GNUC__) || defined( __TASKING__) || defined (__CC_ARM)
      ReentPtr->_errno = EINVAL;
#elif defined  __ICCARM__
      errno = _LLIO_ERROR;
#endif
      break;
    } /* End of "if ( Status != SLTHA_SUCCESS))"*/
    /* Allocate memory to store the file path name.*/
    FileHandle[slotnumber].FilePath = (char *)malloc(pathlen + 1);
    if (FileHandle[slotnumber].FilePath  == NULL)
    {
      break;
    }
    /* Store the file path name */
    strcpy(FileHandle[slotnumber].FilePath, Path);
#if defined(__GNUC__) || defined( __TASKING__)
    ReentPtr->_errno = EIO;
#elif defined __CC_ARM
    errno =  EINVAL;
#elif  __ICCARM__
    errno = _LLIO_ERROR;
#endif
    /* If File Pointer is NULL, then allocate the memory to open a file  */
    if (FileHandle[slotnumber].FatFsPtr == NULL)
    {
      FileHandle[slotnumber].FatFsPtr = (FIL *)calloc(1, sizeof(FIL));
      if (FileHandle[slotnumber].FatFsPtr == NULL)
      {
        status = SLTHA_ERROR;
        break;
      } /* End of "if (FileHandle[SlotNumber].FatFsPtr == NULL))"*/
    } /* End of "if (FileHandle[SlotNumber].FatFsPtr == NULL)"*/
    /* Call the f_open function */
    result = f_open(FileHandle[slotnumber].FatFsPtr, Path, FatFsFlags);
    if (result != FR_OK)
    {
      ReentPtr->_errno = ErrorCodes[result];
      break;
    } /* End of "if( Result != FR_OK)"*/
    filedesc = slotnumber + MONITOR_FATFS;
    FileHandle[slotnumber].Flags = Flags;
    FileHandle[slotnumber].CurrentPos = 0;
    /* if Append flag set, Get the end position by using FatFS lseek function */
    if (Flags & SLTHA_APPEND)
    {
#if (_FS_MINIMIZE == 3U)
      result = FR_DENIED;
#else
      result = f_lseek(FileHandle[slotnumber].FatFsPtr, FileHandle[slotnumber].FatFsPtr->fsize);
#endif
      if (result != FR_OK)
      {
        filedesc = -1;
        break;
      }/* End of "if( Result != FR_OK)"*/
      FileHandle[slotnumber].CurrentPos = FileHandle[slotnumber].FatFsPtr->fptr;
    } /* End of "if(Flags & SLTHA_APPEND)"*/
  } while (0);
  /* Update the Fd in the File Handle. */
  FileHandle[slotnumber].Fd = filedesc;
  status = filedesc;
/* Free the memory if File Handle is -1 and Valid FatFsPtr exists */
  if ((filedesc < 0) &&  (FileHandle[slotnumber].FatFsPtr))
  {
    free (FileHandle[slotnumber].FilePath);
    free (FileHandle [slotnumber].FatFsPtr);
    FileHandle[slotnumber].FilePath = NULL;
    FileHandle[slotnumber].FatFsPtr = NULL;
  } /* End of "if((FileDesc < 0) &&  FileHandle[SlotNumber].FatFsPtr )"*/
  return (status);
}

/*
 * This function closes the file specified by the File descriptor.
 */
SLTHA_Close()
{
#ifdef  __TASKING__
  _err_t status = SLTHA_ERROR;
#else
  int status = SLTHA_ERROR;
#endif
  int slotnumber;
  FRESULT result;
    /* Find the Slot number */
    slotnumber = SLTHA_lFindAvailableSlot(Fd);
    if (slotnumber == MAX_OPEN_FILES)
    {
#if defined(__GNUC__) || defined( __TASKING__)
      ReentPtr->_errno = EBADF;
#elif defined __CC_ARM
      errno = EINVAL;
#elif defined  __ICCARM__
      errno = _LLIO_ERROR;
#endif
    }
    else
    {
      /* Check FilePtr is not Null */
      if (FileHandle[slotnumber].FatFsPtr != NULL)
      {
        result = f_close(FileHandle[slotnumber].FatFsPtr);
        /* Set the handle in the file info structure to -1 */
        free (FileHandle[slotnumber].FilePath);
        free (FileHandle[slotnumber].FatFsPtr);
        FileHandle[slotnumber].FatFsPtr = NULL;
        if (result != FR_OK)
        {
          ReentPtr->_errno = ErrorCodes[result];
        }
        status = SLTHA_SUCCESS;
      }
    }
    /* free the occupied slot */
    FileHandle[slotnumber].Fd = -1;

  return (status);
}

/*
 * This function reads specified bytes of data from the file.
 */
SLTHA_Read()
{
  int slotnumber;
  int bytesread = 0;
  int bytesunread = -1;
  FRESULT result;
    /* Find the Slot number occupied by the file to read from.*/
    slotnumber = SLTHA_lFindAvailableSlot(Fd);
/* Check If write only flag is set  or Max Files are opened.*/
    if ((slotnumber == MAX_OPEN_FILES) || ((FileHandle[slotnumber].Flags & SLTHA_WRONLY) != 0UL))
    {
#if defined(__GNUC__) || defined( __TASKING__)
      ReentPtr->_errno = EBADF;
#elif defined __CC_ARM
      errno = EINVAL;
#elif defined __ICCARM__
      errno = _LLIO_ERROR;
#endif
      bytesread = -1;
   }
   else
   {
    /* Switch as per the file descriptor.*/
    switch (Fd)
    {
     case STDIN_HANDLE:
          break;

     case STDOUT_HANDLE:
           break;

     case STDERR_HANDLE:
           break;

     default:
       if (FileHandle[slotnumber].FatFsPtr != NULL)
       {
/* Call the Fat FS f_read function */
         result = f_read(FileHandle[slotnumber].FatFsPtr, BufferPtr, Length, (UINT *)&bytesread);
         if (result != FR_OK)
         {
           ReentPtr->_errno = ErrorCodes[result];
           bytesread = -1;
           break;
         }
         bytesunread = Length - bytesread;
       }
       break;
    }
    if (bytesunread < 0)
    {
      bytesread = -1;
    }
    FileHandle[slotnumber].CurrentPos += (Length - bytesunread);
  }
  return (bytesread);
}

/*
 * This function writes Length bytes of data into the file specified.
 */
SLTHA_Write()
{
  int slotnumber;
  int byteswritten = 0;
  int bytesunwritten = -1;
#if !_FS_READONLY
  FRESULT result;
#endif
  do
  {
    /* Find the Slot number occupied by the file to read from.*/
    slotnumber = SLTHA_lFindAvailableSlot(Fd);
    /* Check If read only flag is set or Max Files are opened. */
    if ((slotnumber == MAX_OPEN_FILES) || ((FileHandle[slotnumber].Flags & SLTHA_RDONLY ) == 1UL))
    {
#if defined(__GNUC__) || defined( __TASKING__)
      ReentPtr->_errno = EBADF;
#elif defined  __CC_ARM
      errno = EINVAL;
#elif defined  __ICCARM__
      errno = _LLIO_ERROR;
#endif
      break;
    }
/* Switch as per the file descriptor.*/
    switch (Fd)
    {
      case STDIN_HANDLE:
           break;

      case STDOUT_HANDLE:
           break;

      case STDERR_HANDLE:
           break;

      default:
#if _FS_READONLY
    break;
#else
        if (FileHandle[slotnumber].FatFsPtr != NULL)
        {
          /* Call the Fat FS f_write function */
          result = f_write(FileHandle[slotnumber].FatFsPtr, BufferPtr, Length, (UINT *)&byteswritten);
          if (result != FR_OK)
          {
            ReentPtr->_errno = ErrorCodes[result];
            break;
          }
          bytesunwritten = Length - byteswritten;
        }
        break;
#endif
    } /* End of "switch case "*/
  } while (0);
  if((bytesunwritten  == -1) || (bytesunwritten == Length))
  {
    byteswritten = -1;
  }
  else
  {
    FileHandle[slotnumber].CurrentPos += (Length - bytesunwritten);
  }
  return (byteswritten);
}

/*
 * This function Move file pointer of a file object specified by the
 * File Descriptor.
 */
SLTHA_Lseek()
{
  int fileoffset = -1;
#if (_FS_MINIMIZE != 3U)
  int slotnumber;
  FRESULT result;
#endif
  do
  {
#if (_FS_MINIMIZE == 3U)
    break;
#else
    /* Find the Slot number occupied by the file to read from.*/
    slotnumber = SLTHA_lFindAvailableSlot(Fd);
    if ((slotnumber == MAX_OPEN_FILES) ||  (FileHandle[slotnumber].FatFsPtr == NULL))
    {
#if defined(__GNUC__) || defined( __TASKING__)
      ReentPtr->_errno = EBADF;
#elif defined __CC_ARM
      errno = EINVAL;
#elif defined  __ICCARM__
      errno = _LLIO_ERROR;
#endif
      break;
    }
#if defined(__GNUC__) || defined( __TASKING__) || defined( __ICCARM__ )
    /* Check Direction Mode */
    if (DirMode == SEEK_SET)
    {
      result = f_lseek(FileHandle[slotnumber].FatFsPtr, Offset);
    }
    else if (DirMode == SEEK_CUR)
    {
      result = f_lseek(FileHandle[slotnumber].FatFsPtr, FileHandle[slotnumber].FatFsPtr->fptr + Offset);
    }
    else if (DirMode == SEEK_END)
    {
      result = f_lseek (FileHandle[slotnumber].FatFsPtr, FileHandle[slotnumber].FatFsPtr->fsize + Offset);
    }
    else
      break;
#elif __CC_ARM
    result= f_lseek (FileHandle[slotnumber].FatFsPtr, Offset);
#endif
    /* If Fat FS Function call returns Error*/
    if (result != FR_OK)
    {
      ReentPtr->_errno = ErrorCodes[result];
      break;
    }
    FileHandle[slotnumber].CurrentPos = FileHandle[slotnumber].FatFsPtr->fptr;
    fileoffset = FileHandle[slotnumber].CurrentPos;
#endif
  } while (0);
  return (fileoffset);
}

/*
 * This function Delete an existing file or directory.
 */
SLTHA_Remove()
{
  int status = SLTHA_ERROR;
#if ((!_FS_READONLY) && (_FS_MINIMIZE == 0U))
  FRESULT result;
#endif
  do
  {
#if ((_FS_READONLY) || (_FS_MINIMIZE != 0U))
    break;
#else
    /* Call the Fat FS unlink function */
    result = f_unlink(Path);
    if (result != FR_OK)
    {
      ReentPtr->_errno = ErrorCodes[result];
      break;
    }
    status = SLTHA_SUCCESS;
#endif
  } while (0);
  return (status);
}

/*
 * This function gets file status on basis of file descriptor passed.
 */
#if defined  (__GNUC__) || defined ( __TASKING__)
SLTHA_FileStatus()
{
  int status = SLTHA_ERROR;
#if (_FS_MINIMIZE == 0U)
  FILINFO FatFsInfoStruct = {0};
  FRESULT result;
  int slotnumber;
  do
  {
    if ((Fd >= STDIN_HANDLE) && (Fd <= STDERR_HANDLE))
    {
      FileStatusPtr->st_mode = S_IFCHR;
      return 0;
    }
    /* Find the Slot number occupied by the file to read the status*/
    slotnumber = SLTHA_lFindAvailableSlot(Fd);
    /* Call the Fat FS Status function */
    result = f_stat(FileHandle[slotnumber].FilePath, &FatFsInfoStruct);
    if (result != FR_OK)
    {
      ReentPtr->_errno = ErrorCodes[result];
      break;
    }
    SLTHA_lFatInfoToStatus(FileStatusPtr, &FatFsInfoStruct);
    status = SLTHA_SUCCESS;
  } while (0);
#endif
  return (status);
}
/*
 * This function gets file status on basis of file path
 */
SLTHA_Status()
{
  int status = SLTHA_ERROR;
#if (_FS_MINIMIZE == 0U)
  FILINFO FatFsInfoStruct = {0};
  FRESULT result;
  do
  {
    /* Call the Fat FS Status function */
    result = f_stat(Path, &FatFsInfoStruct);
    if (result != FR_OK)
    {
      ReentPtr->_errno = ErrorCodes[result];
      break;
    }
    SLTHA_lFatInfoToStatus(FileStatusPtr,&FatFsInfoStruct);
    status = SLTHA_SUCCESS;
  } while (0);
#endif
  return (status);
}
#endif
#endif


/*
 * This function queries whether output stream is a terminal.
 */
#if defined(__GNUC__)  || defined (__CC_ARM)
SLTHA_IsAtty()
{
  return (Fd <= 2) ? 1 : 0;  /* one of stdin, stdout, stderr */
}
#endif

#if defined(__GNUC__)
/* This function establish a new name for an existing file. This function is not supported by Fat File system.
 */
int _link(char *OldName, char *NewName)
{
  errno = EMLINK;
  return -1;
}
#endif

/*
 * IAR internally calls __dwrite for write system call .
 */
#if defined ( __ICCARM__)
size_t __dwrite(int Fd,const unsigned char *BufferPtr, size_t Length)
{
  return  __write(Fd,BufferPtr,Length);
}
#endif

/*
 * Keil compiler searches for the following system calls while retargetting is
 * done.
 */
#if defined (__CC_ARM)
void _ttywrch(int ch)
{

}

int _sys_ensure(FILEHANDLE Fh)
{
  Fh = Fh;
  return (0);
}

long _sys_flen(FILEHANDLE Fh)
{
  Fh = Fh;
  return (0);
}

int _sys_tmpnam(char *Name, int Sig, unsigned Maxlen)
{
  *Name = *Name;
  Sig = Sig;
  Maxlen = Maxlen;
  return (0);
}

char *_sys_command_string(char *Cmd, int Len)
{
  *Cmd = *Cmd;
  Len = Len;
  return (0);
}

void _sys_exit(int return_code)
{
  /* Endless loop. */
  do{
  } while (1);
}

#endif

#endif

