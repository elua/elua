/**
 * @file spi_master.h
 * @date 2016-04-07
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * SPI_MASTER v4.3.22 - Configures the properties of USIC channel to support SPI mode of communication.
 *
 * Copyright (c) 2015-2017, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-16:
 *     - Initial version<br>
 *
 * 2015-02-20:
 *     - Added 'SPI_MASTER_INPUT_INVALID' in SPI_MASTER_INPUT_t to support dynamic mode change from Dual mode
 *       as well<br>
 *
 * 2015-05-08:
 *     - SPI_MASTER_SetBaudRate() and SPI_MASTER_Transfer() are added<br>
 *     - C++ guard applied to API section only<br>
 *     - File guard updated according to the guidelines<br>
 *     - "SPI_MASTER_STATUS_BUFFER_INVALID" is added in SPI_MASTER_STATUS_t enum<br>
 *     - "leading_trailing_delay" is added in APP config structure<br>
 *     - "tx_data_dummy" is added in Dynamic config structure to support SPI_MASTER_Transfer() API<br>
 *     - XMC_ASSERT() are for NULL handle check in inline APIs<br>
 *     - SPI_MASTER_lTransmitHandler(), SPI_MASTER_lReceiveHandler(), SPI_MASTER_lProtocolHandler() are moved to
 *       spi_master_conf.c file<br>
 *
 * 2015-06-20:
 *     - For SPI_MASTER_Transfer(), SPI_MASTER_Receive(), SPI_MASTER_Transmit() APIs, the input data pointer is changed
 *       from 16-bit to 8-bit.
 *     - word_length fields is added in SPI_MASTER_DYNAMIC_CONFIG_t, to support runtime change.
 *     - Abort API are updated to return the status.
 *
 * 2015-07-07:
 *     - DYNAMIC_CONFIG_t is renamed as RUNTIME_t
 *
 * 2015-09-30:
 *     - New SPI_MASTER_STATUS_MODE_MISMATCH item is added in SPI_MASTER_STATUS_t
 *
 * 2015-10-08:
 *     - SPI_MASTER_DMA_MAXCOUNT is exposed to the user.
 *     - dx0_input_half_duplex is added to support while changing the mode to half duplex mode.
 *     - SPI_MASTER_IsTxBusy() and SPI_MASTER_IsRxBusy() APIs are added to return the current state of the channel.
 *     - Documentation update.
 *
 * 2015-10-14:
 *     - new variable "spi_master_config_mode" to store the actual mode generated during initialisation.
 *
 * 2016-04-07:
 *     - runtime variable are made as volatile.
 *
 * @endcond
 *
 */

#ifndef SPI_MASTER_H
#define SPI_MASTER_H
/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include <xmc_gpio.h>
#include <xmc_scu.h>
#include <xmc_spi.h>
#include <DAVE_Common.h>
#include "spi_master_conf.h"

#if((SPI_MASTER_DMA_TRANSMIT_MODE == 1U) || (SPI_MASTER_DMA_RECEIVE_MODE == 1U))
#include "./GLOBAL_DMA/global_dma.h"
#endif

/**********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/
#if (!((XMC_LIB_MAJOR_VERSION == 2U) && \
       (XMC_LIB_MINOR_VERSION >= 1U) && \
       (XMC_LIB_PATCH_VERSION >= 6U)))
#error "SPI_MASTER requires XMC Peripheral Library v2.1.6 or higher"
#endif


/*
 * @brief Represents the maximum data size for DMA transaction*/
#define SPI_MASTER_DMA_MAXCOUNT (4095U)
/**********************************************************************************************************************
 * ENUMS
 **********************************************************************************************************************/
/**
 * @ingroup SPI_MASTER_enumerations
 * @{
 */
/**
 * @brief Return status of the SPI_MASTER APP
 */
typedef enum SPI_MASTER_STATUS
{
  SPI_MASTER_STATUS_SUCCESS = 0U,   /**< Status success */
  SPI_MASTER_STATUS_FAILURE,        /**< Status failure */
  SPI_MASTER_STATUS_BUSY,           /**< Busy state */
  SPI_MASTER_STATUS_BUFFER_INVALID,  /**< If input buffer and length is invalid */
  SPI_MASTER_STATUS_MODE_MISMATCH   /**< API invoked by a handle configured with different mode.
                                         e.g, If SPI_MASTER_StartTransmitDMA is invoked for an instance
                                         which has transmit mode configured as "Interrupt", will
                                         return this status.*/
} SPI_MASTER_STATUS_t;

/**
 * @brief Service ID for Transmit, Receive and Parity events
 */
typedef enum SPI_MASTER_SR_ID
{
  SPI_MASTER_SR_ID_0 = 0U, /**< SR-0 */
  SPI_MASTER_SR_ID_1,      /**< SR-1 */
  SPI_MASTER_SR_ID_2,      /**< SR-2 */
  SPI_MASTER_SR_ID_3,      /**< SR-3 */
  SPI_MASTER_SR_ID_4,      /**< SR-4 */
  SPI_MASTER_SR_ID_5       /**< SR-5 */
} SPI_MASTER_SR_ID_t;

/**
 * @brief Slave select signals
 */
typedef enum SPI_MASTER_SS_SIGNAL
{
  SPI_MASTER_SS_SIGNAL_0 = 0U, /**< Slave select 0 */
  SPI_MASTER_SS_SIGNAL_1,      /**< Slave select 1 */
  SPI_MASTER_SS_SIGNAL_2,      /**< Slave select 2 */
  SPI_MASTER_SS_SIGNAL_3,      /**< Slave select 3 */
  SPI_MASTER_SS_SIGNAL_4,      /**< Slave select 4 */
  SPI_MASTER_SS_SIGNAL_5,      /**< Slave select 5 */
  SPI_MASTER_SS_SIGNAL_6,      /**< Slave select 6 */
  SPI_MASTER_SS_SIGNAL_7       /**< Slave select 7 */
} SPI_MASTER_SS_SIGNAL_t;

/**
 * @brief Enum type which defines Receive input list
 */
typedef enum SPI_MASTER_INPUT
{
  SPI_MASTER_INPUT_A = 0U, /**< Input-A */
  SPI_MASTER_INPUT_B,      /**< Input-B */
  SPI_MASTER_INPUT_C,      /**< Input-C */
  SPI_MASTER_INPUT_D,      /**< Input-D */
  SPI_MASTER_INPUT_E,      /**< Input-E */
  SPI_MASTER_INPUT_F,      /**< Input-F */
  SPI_MASTER_INPUT_G,      /**< Input-G */
  SPI_MASTER_INPUT_INVALID /**< This is to check during mode switch */
} SPI_MASTER_INPUT_t;

/**
 * @brief Enum used to identify the transfer type used for either transmit or receive function.
 */
typedef enum SPI_MASTER_TRANSFER_MODE
{
  SPI_MASTER_TRANSFER_MODE_INTERRUPT,  /**< Implement data transmit or receive using interrupts */
  SPI_MASTER_TRANSFER_MODE_DMA,        /**< Implement data transmit or receive using DMA */
  SPI_MASTER_TRANSFER_MODE_DIRECT      /**< This configuration exposes signals for external APP connection */
} SPI_MASTER_TRANSFER_MODE_t;
/**
 * @}
 */

typedef void (*SPI_MASTER_functionhandler)(void);
typedef SPI_MASTER_STATUS_t (*SPI_MASTER_lInit_functionhandler)(void);

/***********************************************************************************************************************
* DATA STRUCTURES
***********************************************************************************************************************/
/**
* @ingroup SPI_MASTER_datastructures
* @{
*/

/**
 * @brief Port pin selection for communication
 */
typedef struct SPI_MASTER_GPIO
{
  XMC_GPIO_PORT_t* port;  /**< Reference to the port configuration */
  uint8_t pin;  /**< Selected pin */
} SPI_MASTER_GPIO_t;

/**
 * @brief Pin configuration for the selected pins
 */
typedef struct SPI_MASTER_GPIO_CONFIG
{
  XMC_GPIO_CONFIG_t port_config;  /**< Properties of the port pin */
  XMC_GPIO_HWCTRL_t hw_control;  /**<  hardware control characteristics of the pin */
  XMC_SPI_CH_SLAVE_SELECT_t slave_select_ch;  /**<  Indicates the mapped slave select line  */
} SPI_MASTER_GPIO_CONFIG_t;

/**
 * @brief Configuration parameters of SPI_MASTER APP
 */
 typedef struct SPI_MASTER_CONFIG
{
  XMC_SPI_CH_CONFIG_t * const channel_config;         /**< Reference to SPI configuration structure */
  SPI_MASTER_lInit_functionhandler fptr_spi_master_config;  /**< Function pointer to configure the MUX values*/

  /* Port configuration */
  const SPI_MASTER_GPIO_t* const mosi_0_pin;               /**< Reference to mosi 0 pin */
  const SPI_MASTER_GPIO_CONFIG_t* const mosi_0_pin_config; /**< Reference to mosi 0 pin configuration */
  const SPI_MASTER_GPIO_t* const mosi_1_pin;               /**< Reference to mosi 1 pin */
  const SPI_MASTER_GPIO_CONFIG_t* const mosi_1_pin_config; /**< Reference to mosi 1 pin configuration */
  const SPI_MASTER_GPIO_t* const mosi_2_pin;               /**< Reference to mosi 2 pin */
  const SPI_MASTER_GPIO_CONFIG_t* const mosi_2_pin_config; /**< Reference to mosi 2 pin configuration */
  const SPI_MASTER_GPIO_t* const mosi_3_pin;               /**< Reference to mosi 3 pin */
  const SPI_MASTER_GPIO_CONFIG_t* const mosi_3_pin_config; /**< Reference to mosi 3 pin configuration */
  const SPI_MASTER_GPIO_t* const sclk_out_pin;             /**< Reference to sclk out pin */
  const SPI_MASTER_GPIO_CONFIG_t* const sclk_out_pin_config;/**< Reference to shift clock pin configuration */
  const SPI_MASTER_GPIO_t* const slave_select_pin[8];      /**< Reference to slave select pin */
  const SPI_MASTER_GPIO_CONFIG_t* const slave_select_pin_config[8]; /**< Reference to slave select pin configuration */
  SPI_MASTER_functionhandler tx_cbhandler;            /**< callback handler for end of transmission */
  SPI_MASTER_functionhandler rx_cbhandler;            /**< callback handler for end of reception */
  SPI_MASTER_functionhandler parity_cbhandler;        /**< callback handler for end of parity error */
  /* FIFO configuration */
  XMC_USIC_CH_FIFO_SIZE_t tx_fifo_size;               /**< Number of FIFO entries assigned to the transmit FIFO buffer*/
  XMC_USIC_CH_FIFO_SIZE_t rx_fifo_size;               /**< Number of FIFO entries assigned to the receive FIFO buffer */

  /* Clock Settings */
  XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_t shift_clk_passive_level; /**< Baudrate Generator shift clock passive level*/
  SPI_MASTER_TRANSFER_MODE_t transmit_mode;           /**< Indicates how the transmit mode is being handled */
  SPI_MASTER_TRANSFER_MODE_t receive_mode;            /**< Indicates how the receive mode is being handled */
  XMC_SPI_CH_MODE_t  spi_master_config_mode;          /**< Defines the SPI transmit mode being used */
  uint8_t slave_select_lines;                         /**< Number of slave select lines being used */
  uint8_t leading_trailing_delay;                     /**< Delay before and after each frame in terms of SCLK cycles  */
  SPI_MASTER_SR_ID_t tx_sr;                           /**< Service request number assigned to transmit interrupt */
  SPI_MASTER_SR_ID_t rx_sr;                           /**< Service request number assigned to receive interrupts */
  SPI_MASTER_SR_ID_t parity_sr;                       /**< Service request number assigned to receive interrupts */
} SPI_MASTER_CONFIG_t;

/**
 * @brief Structure to hold the dynamic variables for the SPI_MASTER communication.
 */
typedef struct SPI_MASTER_RUNTIME
{
  uint32_t word_length;                              /**< Indicates the length of the data word */
  uint32_t tx_data_count;                            /**< Number of bytes of data to be transmitted*/
  volatile uint32_t tx_data_index;                   /**< Index to the byte to be transmitted next in the tx_data
                                                          buffer */
  uint32_t rx_data_count;                            /**< Number of bytes of data to be received*/
  volatile uint32_t rx_data_index;                   /**< Indicates the number of bytes currently available in the
                                                          rx_data buffer */
  uint8_t* rx_data;                                  /**< Pointer to the receive data buffer*/
  uint8_t* tx_data;                                  /**< Pointer to the transmit data buffer*/
  volatile XMC_SPI_CH_MODE_t  spi_master_mode;       /**< Defines the SPI transmit mode being used */
  SPI_MASTER_INPUT_t dx0_input;                      /**< DX0 input channel used for Rx input, This is utilized when
                                                          mode is changed to full duplex mode */
  SPI_MASTER_INPUT_t dx0_input_half_duplex;          /**< DX0 input channel used for Rx input, This is utilized when
                                                          mode is changed to half duplex mode */
  volatile bool  rx_busy;                            /**< Status flag to indicate busy when a reception is assigned */
  volatile bool  tx_busy;                            /**< Status flag to indicate busy when a transmission is assigned*/
  volatile bool  tx_data_dummy;                      /**< Status flag to indicate, dummy data is being transmitted */
  volatile bool  rx_data_dummy;                      /**< Status flag to indicate, receive data has to be neglected or
                                                          not */
 } SPI_MASTER_RUNTIME_t;


/**
 * @brief Initialization parameters of SPI_MASTER APP
 */
typedef struct SPI_MASTER
{
  XMC_USIC_CH_t* const channel; /**< Reference to SPI channel */
  const SPI_MASTER_CONFIG_t * const config; /**< Reference to the SPI_MASTER configuration structure */
  SPI_MASTER_RUNTIME_t * const runtime;  /**< Reference to SPI_MASTER dynamic configuration structure */
#if ((SPI_MASTER_DMA_TRANSMIT_MODE == 1U) || (SPI_MASTER_DMA_RECEIVE_MODE == 1U))
  const GLOBAL_DMA_t * const global_dma;
#endif
#if (SPI_MASTER_DMA_TRANSMIT_MODE == 1U)
  const XMC_DMA_CH_CONFIG_t * const dma_ch_tx_config; /**< Reference to the DMA configuration structure for Transmit */
#endif
#if (SPI_MASTER_DMA_RECEIVE_MODE == 1U)
  const XMC_DMA_CH_CONFIG_t * const dma_ch_rx_config; /**< Reference to the DMA configuration structure for Receive */
  const GLOBAL_DMA_t * const global_dma_rx;
  const uint8_t dma_ch_rx_number;
#endif
#if (SPI_MASTER_DMA_TRANSMIT_MODE == 1U)
  const uint8_t dma_ch_tx_number;
#endif
} SPI_MASTER_t;

/**
 * @}
 */
/***********************************************************************************************************************
* API Prototypes
***********************************************************************************************************************/
#ifdef __cplusplus
extern "C" {
#endif
/**
 * @ingroup SPI_MASTER_apidoc
 * @{
 */
/**
 * @brief Get SPI_MASTER APP version
 * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 * <BR>
 * \par<b>Description:</b><br>
 * The function can be used to check application software compatibility with a
 * specific version of the APP.
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   DAVE_APP_VERSION_t app_version;
 *
 *   status = DAVE_Init();    // SPI_MASTER_Init() is called from DAVE_Init()
 *
 *   app_version = SPI_MASTER_GetAppVersion();
 *
 *   if (app_version.major != 4U)
 *   {
 *     // Probably, not the right version.
 *   }
 *
 *   while(1U)
 *   {
 *   }
 *   return 1;
 * }
 * @endcode<BR>
 */
DAVE_APP_VERSION_t SPI_MASTER_GetAppVersion(void);

/**
 * @brief Initialize the SPI channel as per the configuration made in GUI.
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @return SPI_MASTER_STATUS_t: Status of SPI_MASTER driver initialization.\n
 *                    SPI_MASTER_STATUS_SUCCESS - on successful initialization.\n
 *                    SPI_MASTER_STATUS_FAILURE - if initialization fails.\n
 *
 * \par<b>Description:</b><br>
 * Initializes IO pins used for the SPI_MASTER communication and configures USIC registers based on the settings
 * provided in the GUI. Calculates divider values PDIV and STEP for a precise baudrate. It also enables configured
 * interrupt flags and service request values.
 * <BR>
 *
 * Example Usage:
 * @code
 *  #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *  int main(void)
 *  {
 *    DAVE_STATUS_t status;
 *
 *    status = DAVE_Init();    // SPI_MASTER_Init() is called from DAVE_Init()
 *
 *    if(status == DAVE_STATUS_SUCCESS)
 *    {
 *        while(1U)
 *        {
 *        }
 *    }
 *    else
 *    {
 *     XMC_DEBUG("main: Application initialization failed");
 *     while(1U)
 *     {
 *     }
 *    }
 *     return 1U;
 * }
 *  @endcode
 */
SPI_MASTER_STATUS_t SPI_MASTER_Init(SPI_MASTER_t* const handle);

/**
 * @brief Set the communication mode along with required port configuration.
 *
 * @param handle handle Pointer to static and dynamic content of APP configuration.
 * @param mode SPI working mode
 *
 * @return  SPI_MASTER_STATUS_t
 *          SPI_MASTER_STATUS_SUCCESS  : if updation of settings are successful\n
 *          SPI_MASTER_STATUS_FAILURE  : if mode is not supported by the selected pins\n
 *          SPI_MASTER_STATUS_BUSY     : if SPI channel is busy with transmit or receive operation\n
 * <BR>
 *
 * \par<b>Description:</b><br>
 * To change the mode of communication, it is advised to generate the code in Quad/Dual mode initially. Then changing
 * the mode will be taken care by the APP.
 * <ul>
 * <li>If code is generated for Quad mode, it is possible to change to other modes like Dual, Half Duplex and Full Duplex </li>
 * <li>If code is generated for Dual mode, it is possible to change to other modes like Half Duplex and Full Duplex only </li>
 * <li>If code is generated for full-duplex mode, it is possible to change to Half Duplex only </li>
 * </ul>
 * 
 * <BR>
 *
 * Example Usage:
 * <BR>
 * @code
 * #include <DAVE.h>
 *
 *  //Precondition:
 *  //Configure the SPI_MASTER APP operation mode as 'Quad SPI'.
 *  //Description:
 *  //The following code changes the SPI master device mode to Full duplex mode and starts sending the data stored in
 *  //the buffer.
 *
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   SPI_MASTER_STATUS_t spi_status;
 *   uint8_t Send_Data[] = "Infineon DAVE application.";
 *
 *   status = DAVE_Init();    // SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *    spi_status = SPI_MASTER_SetMode(&SPI_MASTER_0, XMC_SPI_CH_MODE_STANDARD);
 *    if(spi_status == SPI_MASTER_STATUS_SUCCESS)
 *    {
 *       SPI_MASTER_Transmit(&SPI_MASTER_0, Send_Data, sizeof(Send_Data));
 *    }
 *   }
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode<BR>
 */

SPI_MASTER_STATUS_t SPI_MASTER_SetMode(SPI_MASTER_t* const handle, const XMC_SPI_CH_MODE_t mode);

/**
 * @brief Set the required baud rate during runtime.
 *
 * @param handle handle Pointer to static and dynamic content of APP configuration.
 * @param baud_rate required baud rate
 *
 * @return  SPI_MASTER_STATUS_t
 *          SPI_MASTER_STATUS_SUCCESS  : if updation of baud rate is successful\n
 *          SPI_MASTER_STATUS_FAILURE  : if updation is failed\n
 *          SPI_MASTER_STATUS_BUSY     : if SPI channel is busy with other operation\n
 * <BR>
 *
 * \par<b>Description:</b><br>
 * While setting the baud rate to avoid noise of the port pins, all the pins are changed to input. After setting the
 * required baud again ports are initialised with the configured settings.
 * <BR>
 *
 * Example Usage:
 * <BR>
 * @code
 * #include <DAVE.h>
 *
 *  //Description:
 *  //The following code changes the SPI master baud rate to 9600 and starts sending the data stored in
 *  //the buffer.
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   SPI_MASTER_STATUS_t spi_status;
 *   uint8_t Send_Data[] = "Infineon DAVE application.";
 *   uint32_t baud_rate;
 *
 *   status = DAVE_Init();    // SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     baud_rate = 9600U;
 *
 *     spi_status = SPI_MASTER_SetBaudRate(&SPI_MASTER_0, baud_rate);
 *
 *     if(spi_status == SPI_MASTER_STATUS_SUCCESS)
 *     {
 *       SPI_MASTER_Transmit(&SPI_MASTER_0, Send_Data, sizeof(Send_Data));
 *     }
 *   }
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode<BR>
 */
SPI_MASTER_STATUS_t SPI_MASTER_SetBaudRate(SPI_MASTER_t* const handle, const uint32_t baud_rate);

/**
 * @brief Transmits the specified number of data words and execute the callback defined in GUI, if enabled.
 *
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @param dataptr Pointer to data
 * @param count number of data words (word length configured) to be transmitted
 *
 * @return  SPI_MASTER_STATUS_t
 *          SPI_MASTER_STATUS_SUCCESS : if transmit is successful\n
 *          SPI_MASTER_STATUS_BUSY : if SPI channel is busy with other operation
 * <BR>
 *
 * \par<b>Description:</b><br>
* Transmits data using the SPI channel as a master device. Transmission is accomplished using the transmit mode
 * as configured in the UI.<br>
 * <b>Interrupt:</b><br>
 * The data transmission is accomplished using transmit interrupt. User can configure
 * a callback function in the APP UI. When the data is fully transmitted, the callback
 * function will be executed. If transmit FIFO is enabled, the trigger limit is set to 1.
 * So the transmit interrupt will be generated when all the data in FIFO is moved out of FIFO.
 * The APP handle's runtime structure is used to store the data pointer, count, data index
 * and status of transmission. This function only registers a data transmission request if
 * there is no active transmission in progress. Actual data transmission happens in the transmit
 * interrupt service routine. A trigger is generated for the transmit interrupt to start loading
 * the data to the transmit buffer. If transmit FIFO is configured, the data is filled into the FIFO.
 * Transmit interrupt will be generated subsequently when the transmit FIFO is empty. At this
 * point of time, if there is some more data to be transmitted, it is loaded to the FIFO again.
 * When FIFO is not enabled, data is transmitted one byte at a time. On transmission of each byte
 * an interrupt is generated and the next byte is transmitted in the interrupt service routine.
 * Callback function is executed when all the data bytes are transmitted.
 * If a callback function is not configured, user has to poll for the value of \a tx_busy flag of
 * the APP handle structure( \a handle->runtime->tx_busy ) to check for
 * the completion of data transmission or use SPI_MASTER_IsTxBusy() API.<br>
 * <b>DMA:</b><br>
 * DMA mode is available only in XMC4x family of microcontrollers. A DMA channel is configured to provide
 * data to the SPI channel transmit buffer. This removes the load off the CPU. This API will only configure
 * and enable the DMA channel by specifying the data buffer and count of bytes to transmit. Rest is taken
 * care without the CPU's intervention. User can configure a callback function in the APP UI. When the
 * transmission is complete, the callback function will be executed. FIFO will not be used in DMA mode.
 * Receive start interrupt is configured for triggering the DMA channel. So each byte is transmitted in
 * the background through the DMA channel.
 * If the callback function is not configured, \a handle->runtime->tx_busy flag can be checked to
 * verify if the transmission is complete.
 * <b>Direct:</b><br>
 * Data will be transmitted using polling method. Status flags are used to check if data can be transmitted.
 * <i><b> Note:</b> In Direct mode, the API blocks the CPU until the count of bytes requested is transmitted.</i>
 *
 * Example Usage:
 * <BR>
 * @code
 * #include <DAVE.h>
 *
 * //Description:
 * //Transmits "Infineon" to the slave device.
 *
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *
 *   uint8_t Send_Data[] = "Infineon";
 *
 *   status = DAVE_Init();    // SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     if(SPI_MASTER_Transmit(&SPI_MASTER_0, Send_Data, sizeof(Send_Data)) == SPI_MASTER_STATUS_SUCCESS)
 *     {
 *       while(SPI_MASTER_0.runtime->tx_busy)
 *       {
 *       }
 *     }
 *   }
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode<BR> </p>
 *
 */
SPI_MASTER_STATUS_t SPI_MASTER_Transmit(const SPI_MASTER_t *const handle, uint8_t* dataptr, uint32_t count);

/**
 * @brief Receives the specified number of data words and execute the callback defined in GUI, if enabled.
 *
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @param dataptr Pointer to data in which value is written
 * @param count number of data words (word length configured) to be read
 *
 * @return  SPI_MASTER_STATUS_t
 *          SPI_MASTER_STATUS_SUCCESS : if read is successful\n
 *          SPI_MASTER_STATUS_BUSY : if SPI channel is busy with other operation
 * <BR>
 * \par<b>Description:</b><br>
 * Data will be received from the SPI slave synchronously. After the requested number of data bytes are received,
 * optionally, the user configured callback function will be executed.
 * Data reception is accomplished using the receive mode selected in the UI.
 * <b>Interrupt:</b><br>
 * Based on the UI configuration, either standard receive buffer(RBUF) or receive FIFO(OUT) is used
 * for data reception. An interrupt is configured for reading received data from the bus. This function
 * only registers a request to receive a number of data bytes from a USIC channel. If FIFO is
 * configured for reception, the FIFO limit is dynamically configured to optimally utilize the
 * CPU load. Before starting data reception, the receive buffers are flushed. So only those data, received
 * after calling the API, will be placed in the user buffer.
 * When all the requested number of data bytes are received, the configured callback
 * function will be executed.
 * If a callback function is not configured, the user has to poll for the value of the
 * variable, \a handle->runtime->rx_busy to be false. The value is updated to \a false when all the
 * requested number of data bytes are received.
 * <br>
 * <b>DMA:</b><br>
 * DMA mode is available only in XMC4x family of microcontrollers. In this mode, a DMA channel is
 * configured for receiving data from standard receive buffer(RBUF) to the user buffer. By calling
 * this API, the DMA channel destination address is configured to the user buffer and the channel is
 * enabled. Receive FIFO will not be used when the receive mode is DMA.
 * Before starting data reception, the receive buffers are flushed. So only those data, received
 * after calling the API, will be placed in the user buffer.
 * When all the requested number of data bytes are received, the configured callback
 * function will be executed.
 * If a callback function is not configured, the user has to poll for the value of the
 * variable, \a handle->runtime->rx_busy to be false. The value is updated to \a false when all the
 * requested number of data bytes are received.
 * <br>
 * <b>Direct</b><br>
 * In Direct receive mode, neither interrupt nor DMA is used. The API polls
 * the receive flag to read the received data and waits for all the requested number of bytes to
 * be received. Based on FIFO configuration, either RBUF or OUT register is used for reading received
 * data. Before starting data reception, the receive buffers are flushed. So only those data, received
 * after calling the API, will be placed in the user buffer.
 * <i><b> Note:</b> In Direct mode, the API blocks the CPU until the count of bytes requested is received.</i>
 * <BR>
 *
 * Example Usage:
 *
 * @code
 * #include <DAVE.h>
 *
 * //Description:
 * //Receives 10 bytes of data from slave.
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   uint8_t ReadData[10];
 *
 *   status =  DAVE_Init();    // SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     if(SPI_MASTER_Receive(&SPI_MASTER_0, ReadData, 10U))
 *     {
 *       while(SPI_MASTER_0.runtime->rx_busy)
 *       {
 *       }
 *     }
 *   }
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode<BR>
 */
SPI_MASTER_STATUS_t SPI_MASTER_Receive(const SPI_MASTER_t *const handle, uint8_t* dataptr, uint32_t count);

/**
 * @brief Transmits and Receives the specified number of data words and execute the receive callback if it is enabled
 *        in GUI.
 *
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @param tx_dataptr Pointer to data buffer which has to be send
 * @param rx_dataptr Pointer to data buffer where the received data has to be stored.
 * @param count number of data words (word length configured) to be read and write
 *
 * @return  SPI_MASTER_STATUS_t
 *          SPI_MASTER_STATUS_SUCCESS   : if transfer of data is successful\n
 *          SPI_MASTER_STATUS_FAILURE   : if transfer of data is failed (or) in other than standard full duplex mode
 *          SPI_MASTER_STATUS_BUFFER_INVALID : if passed buffers are NULL pointers (or) length of data transfer is zero.
 * <BR>
 * \par<b>Description:</b><br>
 * Transmits and receives data simultaneously using the SPI channel as a master device. API is applicable only in
 * <i>Full duplex</> operation mode. Data transfer happens based on the individual modes configured for transmission and
 * reception.<br>
 * Two data pins MOSI and MISO will be used for receiving and transmitting data respectively. A callback function can be
 * configured to execute after completing the transfer when 'Interrupt' or 'DMA' mode is used. The callback function
 * should be configured for <i>End of receive/transfer callback</i> in the 'Interrupt Settings' tab. The callback
 * function will be executed when the last word of data is received.
 *
 * <BR>
 *
 * Example Usage:
 *
 * @code
 * #include <DAVE.h>
 *
 * //Precondition: Operation mode should be 'Full Duplex"
 * //Description:
 * //Transmits and Receives 10 bytes of data from slave in parallel.
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   uint8_t ReadData[10];
 *   uint8_t SendData[10] = {0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA};
 *
 *   status =  DAVE_Init();    // SPI_MASTER_Init() is called from DAVE_Init()
 *
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     SPI_MASTER_Transfer(&SPI_MASTER_0, SendData, ReadData, 10);
 *   }
 *   else
 *   {
 *     XMC_DEBUG("main: Application initialization failed");
 *     while(1U)
 *     {
 *     }
 *   }
 *    return 1U;
 * }
 * @endcode<BR>
 */
SPI_MASTER_STATUS_t SPI_MASTER_Transfer(const SPI_MASTER_t *const handle,
                                        uint8_t* tx_dataptr,
                                        uint8_t* rx_dataptr,
                                        uint32_t count);

#if (SPI_MASTER_INTERRUPT_RECEIVE_MODE == 1U)
/**
 * @brief Receives the specified number of data words and execute the callback defined in GUI, if enabled.
 *
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @param dataptr Pointer to data in which value is written
 * @param count number of data words (word length configured) to be read
 *
 * @return  SPI_MASTER_STATUS_t
 *          SPI_MASTER_STATUS_SUCCESS : if read is successful\n
 *          SPI_MASTER_STATUS_BUSY : if SPI channel is busy with other operation
 *          SPI_MASTER_STATUS_MODE_MISMATCH if receive mode is DMA.
 * <BR>
 * \par<b>Description:</b><br>
 * After receiving the specified number of words (word length configured), the user configured callback function
 * is executed, if it is enabled. If a callback function is not configured on the APP UI, the user has to poll for
 * the status of rx_busy variable of the APP handle structure. Based on the UI configuration, either standard receive
 * buffer or receive FIFO is used for data reception. An interrupt is configured for received data from the bus. This
 * function only registers a request to receive a number of data bytes from a SPI channel. If FIFO is configured for
 * reception, the FIFO limit is dynamically configured to optimally utilize the CPU load.
 * <a href="..\group___architecture___description.html#spi_master_receive_irq_flow_chart">Click here for Flowchart.</a>
 *
 * <BR>
 *
 * Example Usage:
 *
 * @code
 * #include <DAVE.h>
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   uint8_t ReadData[10];
 *
 *   status =  DAVE_Init();    // SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     if(SPI_MASTER_StartReceiveIRQ(&SPI_MASTER_0, ReadData, 10U))
 *     {
 *       while(SPI_MASTER_0.runtime->rx_busy)
 *       {
 *       }
 *       SPI_MASTER_Transmit(&SPI_MASTER_0, ReadData, 10U);
 *     }
 *   }
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode<BR>
 */
SPI_MASTER_STATUS_t SPI_MASTER_StartReceiveIRQ(const SPI_MASTER_t *const handle, uint8_t* dataptr, uint32_t count);
#endif

#if(SPI_MASTER_INTERRUPT_TRANSMIT_MODE == 1U)
/**
 * @brief Transmits the specified number of data words and execute the callback defined in GUI, if enabled.
 *
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @param dataptr Pointer to data
 * @param count number of data words (word length configured) to be transmitted
 *
 * @return  SPI_MASTER_STATUS_t
 *          SPI_MASTER_STATUS_SUCCESS : if transmit is successful\n
 *          SPI_MASTER_STATUS_BUSY : if SPI channel is busy with other operation
 *          SPI_MASTER_STATUS_BUFFER_INVALID : if the data_ptr is NULL or count is 0. \n
 *          SPI_MASTER_STATUS_MODE_MISMATCH : if transmit mode is DMA.
 * <BR>
 *
 * \par<b>Description:</b><br>
 * The data transmission is accomplished using transmit interrupt. After transmitting the total data, the callback
 * function is executed. If transmit FIFO is enabled, the trigger limit is set to 1. So the transmit interrupt is
 * generated when all the data in FIFO is moved from FIFO. The function uses APP handle's dynamic structure to store
 * the data pointer, count, data index and status of transmission. This function only registers a data transmission
 * request if there is no active transmission in progress. Actual data transmission happens in the transmit interrupt
 * service routine. A trigger is generated for the transmit interrupt to start loading the data. If transmit FIFO is
 * configured, the data is filled into the FIFO with trigger limit set to 1. Transmit interrupt will be generated again
 * when the transmit FIFO is empty. At this point of time, if there is some more data to be transmitted, it is loaded
 * to the FIFO again. When FIFO is not enabled, data is transmitted one byte at a time. On transmission of each byte
 * an interrupt is generated and the next byte is transmitted in the interrupt service routine.
 * <a href="..\group___architecture___description.html#spi_master_transmit_irq_flow_chart">Click here for Flowchart.</a>
 *
 * Example Usage:
 * <BR>
 * @code
 * #include <DAVE.h>
 *
 * //Pre-condition:
 * //Transmit mode should be configured as "Interrupt".
 * //Description:
 * //Transmits "Infineon" data to slave.
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *
 *   uint8_t Send_Data[] = "Infineon";
 *
 *   status = DAVE_Init();    // SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     if(SPI_MASTER_StartTransmitIRQ(&SPI_MASTER_0, Send_Data, sizeof(Send_Data)) == SPI_MASTER_STATUS_SUCCESS)
 *     {
 *       while(SPI_MASTER_0.runtime->tx_busy)
 *       {
 *       }
 *     }
 *   }
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode<BR> </p>
 *
 */
SPI_MASTER_STATUS_t SPI_MASTER_StartTransmitIRQ(const SPI_MASTER_t *const handle, uint8_t *addr, uint32_t count);
#endif


#if(SPI_MASTER_DMA_RECEIVE_MODE == 1U)
/**
 * @brief Registers a request for receiving data over SPI_MASTER channel using DMA.
 *
 *
 * @param  handle  Pointer to SPI_MASTER_t handle structure
 * @param data_ptr  Pointer to data of type uint8_t.
 * @param  count  Total no of bytes to be received.\n
 *                \b Range: minimum= 1, maximum= 4096.
 *
 * @return  SPI_MASTER_STATUS_t: Status for receive request.\n
 *                        @ref SPI_MASTER_STATUS_SUCCESS if the request is accepted.\n
 *                        @ref SPI_MASTER_STATUS_BUSY if a reception is in progress.\n
 *                        @ref SPI_MASTER_STATUS_BUFFER_INVALID if the data_ptr is NULL or count is 0. \n
 *                        @ref SPI_MASTER_STATUS_MODE_MISMATCH : if receive mode is Interrupt \n
 *
 *
 * \par<b>Description:</b><br>
 * Data will be received asynchronously. When the requested number of data bytes are received,
 * optionally, the user configured callback function will be executed.
 * This function only registers a request to receive a number of data bytes from a USIC channel.
 * When all the requested number of data bytes are received, the configured callback
 * function will be executed.
 * If a callback function is not configured, the user has to poll for the value of the
 * variable, \a handle->runtime->rx_busy to be false. The value is updated to \a false when all the
 * requested number of data bytes are received.
 * A maximum of 4096 bytes can be received in one API call. This limit is because of the DMA single block size.
 * <a href="..\group___architecture___description.html#spi_master_receive_dma_flow_chart">Click here for Flowchart.</a>
 *
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Pre condition:
 *   //Receive mode should be configured to "DMA"
 *   //Description: Receive 10 bytes from slave.
 *
 *
 *   int main(void)
 *   {
 *     SPI_MASTER_STATUS_t init_status;
 *     uint8_t ReadData[10];
 *
 *     init_status = (SPI_MASTER_STATUS_t)SPI_MASTER_Init(&SPI_MASTER_0);
 *     if(init_status == SPI_MASTER_STATUS_SUCCESS)
 *     {
 *       if(SPI_MASTER_StartReceiveDMA(&SPI_MASTER_0, ReadData, 10) == SPI_MASTER_STATUS_SUCCESS)
 *       {
 *         while(SPI_MASTER_0.runtime->rx_busy)
 *         {
 *         }
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 *  @endcode
 *
 */
SPI_MASTER_STATUS_t SPI_MASTER_StartReceiveDMA(const SPI_MASTER_t  *const handle, uint8_t *addr, uint32_t block_size);
#endif

#if(SPI_MASTER_DMA_TRANSMIT_MODE == 1U)
/**
 * @brief Registers a request for transmitting data over SPI_MASTER channel using DMA.
 *
 * @param  handle  SPI_MASTER APP handle pointer of type @ref SPI_MASTER_t
 * @param  data_ptr Pointer to data of type uint8_t.
 * @param  count Total number of words to be transmitted.\n
 * \b Range: minimum= 1, maximum= 4096.
 *
 * @return  SPI_MASTER_STATUS_t: Status of transmit request.\n
 *                        @ref SPI_MASTER_STATUS_SUCCESS if the request is accepted.\n
 *                        @ref SPI_MASTER_STATUS_BUSY if a transmission is in progress.\n
 *                        @ref SPI_MASTER__STATUS_BUFFER_INVALID if the data_ptr is NULL or count is 0. \n
 *                        @ref SPI_MASTER_STATUS_MODE_MISMATCH : if transmit mode is Interrupt \n
 *
 * <i>Imp Note:</i> Return value should be validated by user to ensure that the
 * request is registered.
 *
 * \par<b>Description:</b><br>
 * The data transmission is accomplished using DMA. User can configure a callback function in the APP UI. When the data
 * is fully transmitted, the callback function will be executed.
 * The function uses APP handle's runtime structure to store the status of transmission.
 * This function only registers a data transmission request, if there is no active transmission in progress. Actual
 * data transmission happens through DMA channel. A maximum of 4095 bytes can be transmitted in one API call. This limit
 * is because of the DMA single block size. Callback function is executed when all the data bytes are transmitted.
 * If a callback function is not configured, user has to poll for the value of \a tx_busy flag of
 * the APP handle structure( \a handle->runtime->tx_busy ) to check for the completion of data transmission.
 * If data more than the block size of 4095 have to be transmitted, user will have to transmit them using
 * multiple calls to this API.
 * <a href="..\group___architecture___description.html#spi_master_transmit_dma_flow_chart">Click here for Flowchart.</a>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Pre-condition:
 *   //Transmit mode should be configured as "DMA".
 *   //Description: Transmits "Infineon" data to the slave
 *
 *
 *   int main(void)
 *   {
 *     SPI_MASTER_STATUS_t init_status;
 *     uint8_t Send_Data[] = "Infineon";
 *
 *     init_status = (SPI_MASTER_STATUS_t)SPI_MASTER_Init(&SPI_MASTER_0);
 *     if(init_status == SPI_MASTER_STATUS_SUCCESS)
 *     {
 *       if(SPI_MASTER_StartTransmitDMA(&SPI_MASTER_0, Send_Data, sizeof(Send_Data)) == SPI_MASTER_STATUS_SUCCESS)
 *       {
 *         while(SPI_MASTER_0.runtime->tx_busy)
 *         {
 *         }
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
SPI_MASTER_STATUS_t SPI_MASTER_StartTransmitDMA(const SPI_MASTER_t *const handle, uint8_t *addr, uint32_t block_size);
#endif

/**
 * @brief Returns the state of the specified interrupt flag.
 *
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @param flag Interrupt for which status is required
 *             Use type @ref XMC_SPI_CH_STATUS_FLAG_t for the bitmask of events.
 * @return  uint32_t status of the interrupt
 * <BR>
 *
 * \par<b>Description:</b><br>
 * Returns the status of the events, by reading PSR register. This indicates the status of the all the events, for
 * SPI communication.
 * <BR>
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *
 * //Description:
 * //It transmits "Infineon" to the SPI slave. After calling the transmit API, it will poll for the transmit shift
 * //indication flag to know the data has shifted out or not.
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   uint8_t Send_Data[] = "Infineon";
 *
 *   status = DAVE_Init();    // SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     SPI_MASTER_Transmit(&SPI_MASTER_0, Send_Data, sizeof(Send_Data));
 *     while(SPI_MASTER_GetFlagStatus(&SPI_MASTER_0, XMC_SPI_CH_STATUS_FLAG_TRANSMIT_SHIFT_INDICATION));
 *   }
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode<BR>
 *
 */

__STATIC_INLINE uint32_t SPI_MASTER_GetFlagStatus(const SPI_MASTER_t* handle, const uint32_t flag)
{
  XMC_ASSERT("SPI_MASTER_GetFlagStatus:handle NULL" , (handle != NULL));
  return (XMC_SPI_CH_GetStatusFlag(handle->channel) & flag);
}

/**
 * @brief Clears the status of the specified interrupt flags.
 *
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @param flag_mask Interrupt for which status has to be cleared
 *             Use type @ref XMC_SPI_CH_STATUS_FLAG_t for the bitmask of events.
 * <BR>
 * \par<b>Description:</b><br>
 * During communication the events occurred has to be cleared to get the successive events.\n
 * e.g: During transmission Transmit buffer event occurs to indicating data word transfer has started. This event has
 * to be cleared after transmission of each data word. Otherwise next event is not considered as valid.
 * <BR>
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *
 * //Description:
 * //It transmits "Infineon" to the SPI slave. After calling the transmit API, it will poll for the transmit shift
 * //indication flag to know the data has shifted out or not, and clears the flag.
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   uint8_t Send_Data[] = "Infineon";
 *
 *   status = DAVE_Init();    // SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     SPI_MASTER_Transmit(&SPI_MASTER_0, Send_Data, sizeof(Send_Data));
 *     while(SPI_MASTER_GetFlagStatus(&SPI_MASTER_0, (uint32_t)XMC_SPI_CH_STATUS_FLAG_TRANSMIT_SHIFT_INDICATION));
 *     SPI_MASTER_ClearFlag(&SPI_MASTER_0, (uint32_t)XMC_SPI_CH_STATUS_FLAG_TRANSMIT_SHIFT_INDICATION);
 *   }
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode<BR>
 */
__STATIC_INLINE void SPI_MASTER_ClearFlag(const SPI_MASTER_t* handle, const uint32_t flag_mask)
{
    XMC_ASSERT("SPI_MASTER_ClearFlag:handle NULL" , (handle != NULL));
    XMC_SPI_CH_ClearStatusFlag(handle->channel, flag_mask);
}

/**
 * @brief return the txbusy flag state
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @return bool : status of txbusy flag
 *
 * <BR>
 * \par<b>Description:</b><br>
 * This is used to check whether any transmit process is going or not. If no process is going then only
 * the new request is accepted. SPI_MASTER_AbortTransmit() can be used to stop the current process and
 * start the new request.
 * <BR>
 *
 * Example Usage:
 * <BR>
 * @code
 * #include <DAVE.h>
 *
 * //Description:
 * //Transmits "Infineon" to the slave device.
 *
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *
 *   uint8_t Send_Data[] = "Infineon";
 *
 *   status = DAVE_Init();    // SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     if(SPI_MASTER_Transmit(&SPI_MASTER_0, Send_Data, sizeof(Send_Data)) == SPI_MASTER_STATUS_SUCCESS)
 *     {
 *       while(SPI_MASTER_IsTxBusy(&SPI_MASTER_0))
 *       {
 *       }
 *     }
 *   }
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode<BR> </p>
 *
 */
__STATIC_INLINE bool SPI_MASTER_IsTxBusy(const SPI_MASTER_t* const handle)
{
  XMC_ASSERT("SPI_MASTER_IsTxBusy:handle NULL", (handle != NULL))
  return (handle->runtime->tx_busy);
}

/**
 * @brief return the rxbusy flag state
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @return bool : status of rxbusy flag
 *
 * <BR>
 * \par<b>Description:</b><br>
 * This is used to check whether any receive process is going or not. If no process is going then only
 * the new request is accepted. SPI_MASTER_AbortReceive() can be used to stop the current process and
 * start the new request.
 * <BR>
 *
 * Example Usage:
 *
 * @code
 * #include <DAVE.h>
 *
 * //Description:
 * //Receives 10 bytes of data from slave.
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   uint8_t ReadData[10];
 *
 *   status =  DAVE_Init();    // SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     if(SPI_MASTER_Receive(&SPI_MASTER_0, ReadData, 10U))
 *     {
 *       while(SPI_MASTER_IsRxBusy(&SPI_MASTER_0))
 *       {
 *       }
 *     }
 *   }
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode<BR>
 */
__STATIC_INLINE bool SPI_MASTER_IsRxBusy(const SPI_MASTER_t* const handle)
{
  XMC_ASSERT("SPI_MASTER_IsTxBusy:handle NULL", (handle != NULL))
  return (handle->runtime->rx_busy);
}


/**
 * @brief Enables the specified slave select line
 *
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @param slave which slave signal has to be enabled
 * <BR>
 * \par<b>Description:</b><br>
 * Each slave is connected with one slave select signal. At a time only one slave can be communicate. Enable the
 * required slave to start the communication.
 * <BR>
 *
 * Example Usage:
 * Generate code for multiple slave by configuring in "Advanced settings tab". Transmit the data to the required slave.
 * @code
 *
 * #include <DAVE.h>
 *
 * //Precondition:
 * //Configure to use two slaves".
 * //Description:
 * //Transmits 10 bytes of data to slave-0 and disables the slave-o. Then enable the slave-1 and transmits the data.
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   uint8_t Send_Data[] = "Infineon";
 *
 *   status = DAVE_Init();    // SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     SPI_MASTER_Transmit(&SPI_MASTER_0, Send_Data, sizeof(Send_Data));
 *     SPI_MASTER_DisableSlaveSelectSignal(&SPI_MASTER_0);
 *     SPI_MASTER_EnableSlaveSelectSignal(&SPI_MASTER_0, SPI_MASTER_SS_SIGNAL_1);
 *     SPI_MASTER_Transmit(&SPI_MASTER_0, Send_Data, sizeof(Send_Data));
 *   }
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode<BR>
 *
 */
__STATIC_INLINE void SPI_MASTER_EnableSlaveSelectSignal(const SPI_MASTER_t* handle, const SPI_MASTER_SS_SIGNAL_t slave)
{
    XMC_ASSERT("SPI_MASTER_EnableSlaveSelectSignal:handle NULL" , (handle != NULL));
    XMC_ASSERT("SPI_MASTER_EnableSlaveSelectSignal:Invalid Slave selection" , ((slave == SPI_MASTER_SS_SIGNAL_0) ||
                                                                               (slave == SPI_MASTER_SS_SIGNAL_1) ||
                                                                               (slave == SPI_MASTER_SS_SIGNAL_2) ||
                                                                               (slave == SPI_MASTER_SS_SIGNAL_3) ||
                                                                               (slave == SPI_MASTER_SS_SIGNAL_4) ||
                                                                               (slave == SPI_MASTER_SS_SIGNAL_5) ||
                                                                               (slave == SPI_MASTER_SS_SIGNAL_6) ||
                                                                               (slave == SPI_MASTER_SS_SIGNAL_7))
                                                                              );
    XMC_SPI_CH_EnableSlaveSelect(handle->channel, handle->config->slave_select_pin_config[slave]->slave_select_ch);
}

/**
 * @brief Disables the all the slave select lines
 *
 * @param handle Pointer to static and dynamic content of APP configuration.
 * <BR>
 * \par<b>Description:</b><br>
 * Disable all the slave signals by clearing PCR.SELO bits.
 * <BR>
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *
 * //Precondition:
 * //Configure to use two slaves".
 * //Description:
 * //Transmits 10 bytes of data to slave-0 and disables the slave-o. Then enable the slave-1 and transmits the data.
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   uint8_t Send_Data[] = "Infineon";
 *
 *   status = DAVE_Init();    // SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     SPI_MASTER_Transmit(&SPI_MASTER_0, Send_Data, sizeof(Send_Data));
 *     SPI_MASTER_DisableSlaveSelectSignal(&SPI_MASTER_0);
 *     SPI_MASTER_EnableSlaveSelectSignal(&SPI_MASTER_0, SPI_MASTER_SS_SIGNAL_1);
 *     SPI_MASTER_Transmit(&SPI_MASTER_0, Send_Data, sizeof(Send_Data));
 *   }
 *
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode<BR>
 *
 */
__STATIC_INLINE void SPI_MASTER_DisableSlaveSelectSignal(const SPI_MASTER_t* handle)
{
    XMC_ASSERT("SPI_MASTER_Transmit:handle NULL" , (handle != NULL));
    XMC_SPI_CH_DisableSlaveSelect(handle->channel);
}

/**
 * @brief Provides data received in the receive buffer.
 *
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @return uint16_t Data read from the receive buffer.
 *
 * \par<b>Description:</b><br>
 * This can be used in receive mode "Direct" to read the received data.
 * If receive FIFO is not configured, function reads the value of RBUF register.
 * Otherwise the data is read from OUTR register.
 * User can poll for receive event or configure an interrupt by connecting
 * external INTERRUPT APP with receive event signals. This API can be used inside the ISR to read the received data.
 * <BR>
 *
 */
__STATIC_INLINE uint16_t SPI_MASTER_GetReceivedWord(const SPI_MASTER_t *const handle)
{
  XMC_ASSERT("SPI_MASTER_GetReceivedWord:handle NULL" , (handle != NULL));
  return XMC_SPI_CH_GetReceivedData(handle->channel);
}

/**
 * @brief Transmits a word of data.
 *
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @param data Data to be transmitted
 *
 * \par<b>Description:</b><br>
 * Transmits a word of data through the SPI channel as a master device.
 * If transmit FIFO is configured, the data is placed in the IN[0] register of the USIC channel.
 * If transmit FIFO is not configured, API waits for the TBUF to be free and then places the data in the TBUF register.
 * User can poll for receive event or configure interrupt by connecting an
 * external INTERRUPT APP. This API can be used inside the ISR to read the received data.
 */
__STATIC_INLINE void SPI_MASTER_TransmitWord(const SPI_MASTER_t *const handle, const uint16_t data)
{
  XMC_ASSERT("SPI_MASTER_TransmitWord:handle NULL" , (handle != NULL));
  XMC_SPI_CH_Transmit(handle->channel, data, handle->runtime->spi_master_mode);
}

/**
 * @brief Enables the selected protocol events for interrupt generation.
 *
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @param event Protocol events which have to be enabled.
 *              Refer @ XMC_SPI_CH_EVENT_t for valid values. <b>OR</b> combinations of these enum items can be used
 *              as input.
 *
 * \par<b>Description:</b><br>
 * Enables the events by configuring CCR or PCR register based on the event.
 * When the event is enabled, an interrupt can be generated on occurrence of the event.
 * The API can be used for protocol events(PCR_SSC events) only when the callback functions are not registered under
 * 'Error and Protocol Handling' group.
 *
 */
__STATIC_INLINE void SPI_MASTER_EnableEvent(const SPI_MASTER_t *const handle, const uint32_t event_mask)
{
  XMC_ASSERT("SPI_MASTER_EnableEvent:handle NULL" , (handle != NULL));
  XMC_SPI_CH_EnableEvent(handle->channel, event_mask);
}

/**
 * @brief Disables selected events from generating interrupt.
 *
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @param event Protocol events which have to be disabled.
 *              Refer @ XMC_SPI_CH_EVENT_t for valid values. <b>OR</b> combinations of these enum item can be used
 *              as input.
 *
 * \par<b>Description:</b><br>
 * Disables the SPI protocol specific events, by configuring PCR register.\n\n
 * After disabling the events, SPI_MASTER_EnableEvent() has to be invoked to re-enable the events.
 */
__STATIC_INLINE void SPI_MASTER_DisableEvent(const SPI_MASTER_t *const handle, const uint32_t event_mask)
{
  XMC_ASSERT("SPI_MASTER_DisableEvent:handle NULL" , (handle != NULL));
  XMC_SPI_CH_DisableEvent(handle->channel, event_mask);
}

/**
 * @brief Configures trigger limit for the transmit FIFO.
 *
 * @param handle Pointer to static and dynamic content of APP configuration. \n
 * @param limit Value of transmit FIFO filling level, transition below which the interrupt should be generated.\n
 *              \bRange: 0 to transmit FIFO size.\n
 *              e.g, If transmit FIFO size is 16, and limit is configured as 8, FIFO standard transmit buffer interrupt
 *              will be generated when the FIFO filling level drops from 8 to 7.\n
 *
 * \par<b>Description</b><br>
 * Transmit FIFO trigger limit is configured by setting its value in the TBCTR register.
 * Transmit FIFO is configured to generate interrupt when the FIFO filling level drops
 * below the trigger limit.
 */
__STATIC_INLINE void SPI_MASTER_SetTXFIFOTriggerLimit(const SPI_MASTER_t *const handle, const uint32_t limit)
{
  XMC_ASSERT("SPI_MASTER_SetTXFIFOTriggerLimit:handle NULL" , (handle != NULL));
  XMC_USIC_CH_TXFIFO_SetSizeTriggerLimit(handle->channel, handle->config->tx_fifo_size, limit);
}

/**
 * @brief Configures trigger limit for the receive FIFO.
 *
 * @param handle Pointer to static and dynamic content of APP configuration. \n
 * @param size Value of receive FIFO filling level, transition above which the interrupt should be generated.\n
 *               \bRange: 0 to receive FIFO size.\n
 *               e.g, If receive FIFO size is 16, and limit is configured as 8, FIFO receive buffer interrupt
 *               will be generated when the FIFO filling level rises from 8 to 9.\n
 *
 *
 * \par<b>Description</b><br>
 * Receive FIFO trigger limit is configured by setting its value in the RBCTR register.
 * Receive FIFO is configured to generate interrupt when the FIFO filling level rises
 * above the trigger limit.
 */
__STATIC_INLINE void SPI_MASTER_SetRXFIFOTriggerLimit(const SPI_MASTER_t *const handle, const uint32_t limit)
{
  XMC_ASSERT("SPI_MASTER_SetRXFIFOTriggerLimit:handle NULL" , (handle != NULL));
  XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit(handle->channel, handle->config->rx_fifo_size, limit);
}

/**
 * @brief Enables the interrupt events related to transmit FIFO.
 *
 * @param handle Pointer to static and dynamic content of APP configuration. \n
 * @param event Events to be enabled. Multiple events can be bitwise OR combined. \n
 *              @ref XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD, @ref XMC_USIC_CH_TXFIFO_EVENT_CONF_ERROR.
 *
 * \par<b>Description</b><br>
 * Event bitmasks can be constructed using the enumeration @ref XMC_USIC_CH_TXFIFO_EVENT_CONF.For providing
 * multiple events, combine the events using bitwise OR operation. Events are configured in the TBCTR register.<br>
 */
__STATIC_INLINE void SPI_MASTER_TXFIFO_EnableEvent(const SPI_MASTER_t *const handle, const uint32_t event)
{
  XMC_ASSERT("SPI_MASTER_TXFIFO_EnableEvent:handle NULL" , (handle != NULL));
  XMC_USIC_CH_TXFIFO_EnableEvent(handle->channel, event);
}

/**
 * @brief Disables the interrupt events related to transmit FIFO.
 *
 * @param handle Pointer to static and dynamic content of APP configuration. \n
 * @param event Events to be disabled. \n
 *  \b Range: @ref XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD, @ref XMC_USIC_CH_TXFIFO_EVENT_CONF_ERROR.
 *
 * \par<b>Description</b><br>
 * By disabling the interrupt events, generation of interrupt is stopped. User can poll the event
 * flags from the status register using the API SPI_MASTER_TXFIFO_GetEvent().
 * Event bitmasks can be constructed using the enumeration @ref XMC_USIC_CH_TXFIFO_EVENT_CONF. For providing
 * multiple events, combine the events using bitwise OR operation.
 */
__STATIC_INLINE void SPI_MASTER_TXFIFO_DisableEvent(const SPI_MASTER_t *const handle, const uint32_t event)
{
  XMC_ASSERT("SPI_MASTER_TXFIFO_DisableEvent:handle NULL" , (handle != NULL));
  XMC_USIC_CH_TXFIFO_DisableEvent(handle->channel, event);
}

/**
 * @brief Gets the transmit FIFO event status.
 *
 * @param handle Pointer to static and dynamic content of APP configuration. \n
 * @return Status of standard transmit and transmit buffer error events. \n
 *         \b Range: @ref XMC_USIC_CH_TXFIFO_EVENT_STANDARD, @ref XMC_USIC_CH_TXFIFO_EVENT_ERROR.
 *
 * \par<b>Description</b><br>
 * Gives the status of transmit FIFO standard transmit buffer event and transmit buffer error event.
 * The status bits are located at their bit positions in the TRBSR register in the returned value.
 * User can make use of the @ref XMC_USIC_CH_TXFIFO_EVENT enumeration for checking the status of return value.
 * The status can be found by using the bitwise AND operation on the returned value with the enumerated value.<br>
 */
__STATIC_INLINE uint32_t SPI_MASTER_TXFIFO_GetEvent(const SPI_MASTER_t *const handle)
{
  XMC_ASSERT("SPI_MASTER_TXFIFO_GetEvent:handle NULL" , (handle != NULL));
  return XMC_USIC_CH_TXFIFO_GetEvent(handle->channel);
}

/**
 * @brief Clears the transmit FIFO event flags in the status register.
 *
 * @param handle Pointer to static and dynamic content of APP configuration. \n
 * @param  event Transmit FIFO events to be cleared. \n
 *               \b Range: @ref XMC_USIC_CH_TXFIFO_EVENT_STANDARD, @ref XMC_USIC_CH_TXFIFO_EVENT_ERROR.
 * @return None
 *
 * \par<b>Description</b><br>
 * USIC channel peripheral does not clear the event flags after they are read.
 * This API clears the events provided in the \a mask value.
 * XMC_USIC_CH_TXFIFO_EVENT enumeration can be used as input. Multiple events
 * can be cleared by providing a mask value obtained by bitwise OR operation of
 * multiple event enumerations.
 */
__STATIC_INLINE void SPI_MASTER_TXFIFO_ClearEvent(const SPI_MASTER_t *const handle, const uint32_t event)
{
  XMC_ASSERT("SPI_MASTER_TXFIFO_ClearEvent:handle NULL" , (handle != NULL));
  XMC_USIC_CH_TXFIFO_ClearEvent(handle->channel, event);
}

/**
 * @brief Checks if the transmit FIFO is full.
 *
 * @param handle Pointer to static and dynamic content of APP configuration. \n
 * @return bool Status of transmit FIFO filling level.<br>
 *             true - if transmit FIFO is full.<br>
 *             false - if transmit FIFO is not full.<br>
 *
 * \par<b>Description</b><br>
 * Checks if transmit FIFO is full. \n\n
 * Checks the status using the register TRBSR. Can be used while filling
 * data to the transmit FIFO.
 */
__STATIC_INLINE bool SPI_MASTER_IsTxFIFOFull(const SPI_MASTER_t* const handle)
{
  XMC_ASSERT("SPI_MASTER_IsTxFIFOFull:handle NULL", (handle != NULL))
  return XMC_USIC_CH_TXFIFO_IsFull(handle->channel);
}

/**
 * @brief Enables the interrupt events related to transmit FIFO.
 *
 * @param handle Pointer to static and dynamic content of APP configuration. \n
 * @param event Events to be enabled. Multiple events can be bitwise OR combined. \n
 *          \b Range: @ref XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD, @ref XMC_USIC_CH_RXFIFO_EVENT_CONF_ERROR,
 *          @ref XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE.
 *
 * \par<b>Description</b><br>
 * Multiple events can be enabled by providing multiple events in a single call. For providing
 * multiple events, combine the events using bitwise OR operation.<br>
 */
__STATIC_INLINE void SPI_MASTER_RXFIFO_EnableEvent(const SPI_MASTER_t *const handle, const uint32_t event)
{
  XMC_ASSERT("SPI_MASTER_RXFIFO_EnableEvent:handle NULL" , (handle != NULL));
  XMC_USIC_CH_RXFIFO_EnableEvent(handle->channel, event);
}

/**
 * @brief Disables the selected interrupt events related to receive FIFO.
 *
 * @param handle Pointer to static and dynamic content of APP configuration. \n
 * @param event Events to be disabled. \n
 *          \b Range: @ref XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD, @ref XMC_USIC_CH_RXFIFO_EVENT_CONF_ERROR,
 *          @ref XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE.
 *
 * \par<b>Description</b><br>
 * By disabling the interrupt events, generation of interrupt is stopped. User can poll the event
 * flags from the status register using the API SPI_MASTER_RXFIFO_GetEvent().
 */
__STATIC_INLINE void SPI_MASTER_RXFIFO_DisableEvent(const SPI_MASTER_t *const handle, const uint32_t event)
{
  XMC_ASSERT("SPI_MASTER_RXFIFO_DisableEvent:handle NULL" , (handle != NULL));
  XMC_USIC_CH_RXFIFO_DisableEvent(handle->channel, event);
}

/**
 * @brief  Get the receive FIFO events status.
 *
 * @param handle Pointer to static and dynamic content of APP configuration. \n
 * @return uint32_t Status of receive FIFO events.<br>
 *
 * \par<b>Description</b><br>
 * Gives the status of receive FIFO standard receive buffer event, alternative receive buffer event and
 * receive buffer error event. The status bits are located at their bit positions in the TRBSR register in
 * the returned value. User can make use of the XMC_USIC_CH_RXFIFO_EVENT enumeration for checking the status
 * of return value.
 */
__STATIC_INLINE uint32_t SPI_MASTER_RXFIFO_GetEvent(const SPI_MASTER_t *const handle)
{
  XMC_ASSERT("SPI_MASTER_RXFIFO_GetEvent:handle NULL" , (handle != NULL));
  return XMC_USIC_CH_RXFIFO_GetEvent(handle->channel);
}

/**
 * @brief Clears the receive FIFO event flags in the status register.
 *
 * @param handle Pointer to static and dynamic content of APP configuration. \n
 * @param  event Receive FIFO events to be cleared. \n
 *          \b Range: @ref XMC_USIC_CH_RXFIFO_EVENT_STANDARD, @ref XMC_USIC_CH_RXFIFO_EVENT_ERROR,
 *                    @ref XMC_USIC_CH_RXFIFO_EVENT_ALTERNATE.
 *
 * \par<b>Description</b><br>
 * USIC channel peripheral does not clear the event flags after they are read.
 * This API clears the events provided in the \a mask value.
 * XMC_USIC_CH_RXFIFO_EVENT enumeration can be used as input.
 */
__STATIC_INLINE void SPI_MASTER_RXFIFO_ClearEvent(const SPI_MASTER_t *const handle, const uint32_t event)
{
  XMC_ASSERT("SPI_MASTER_RXFIFO_ClearEvent:handle NULL" , (handle != NULL));
  XMC_USIC_CH_RXFIFO_ClearEvent(handle->channel, event);
}

/**
 * @brief Checks if receive FIFO is empty.
 *
 * @param handle Pointer to static and dynamic content of APP configuration. \n
 * @return bool true if receive FIFO is empty,
 *              false if receive FIFO has some data.
 *
 * \par<b>Description</b><br>
 * When the receive FIFO is empty, received data will be put in receive FIFO.
 * When the last received word in the FIFO is read, FIFO empty flag is set. Any attempt
 * to read from an empty receive FIFO will set the receive FIFO error flag.
 */
__STATIC_INLINE bool SPI_MASTER_IsRxFIFOEmpty(const SPI_MASTER_t* const handle)
{
  XMC_ASSERT("SPI_MASTER_IsRxFIFOEmpty:handle NULL", (handle != NULL))
  return XMC_USIC_CH_RXFIFO_IsEmpty(handle->channel);
}

/**
 * @brief Aborts the ongoing data transmission.
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @return None
 *
 * \par<b>Description:</b><br>
 * If there is a transmission in progress, it will be stopped. If transmit FIFO is used,
 * the existing data will be flushed. After the transmission is stopped, user can start
 * a new transmission without delay.
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *  //Description:
 *  //Transmits test data from buffer Send_Data and aborts it immediately.
 *  //Retransmits data from NewData.
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   uint8_t Send_Data[] = "Infineon DAVE application.";
 *   uint8_t NewData[] = "New data message";
 *
 *   status = DAVE_Init();    // SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     SPI_MASTER_Transmit(&SPI_MASTER_0, Send_Data, sizeof(Send_Data));
 *
 *     if(SPI_MASTER_0.runtime->tx_busy)
 *     {
 *       SPI_MASTER_AbortTransmit(&SPI_MASTER_0);
 *       SPI_MASTER_Transmit(&SPI_MASTER_0, NewData, sizeof(NewData));
 *     }
 *   }
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode
 *
 */
SPI_MASTER_STATUS_t SPI_MASTER_AbortTransmit(const SPI_MASTER_t *const handle);

/**
 * @brief Stops the active data reception request.
 * @param handle Pointer to static and dynamic content of APP configuration.
 * @return None
 * <BR>
 * \par<b>Description:</b><br>
 * If a reception is in progress, it will be stopped. When a reception request
 * is active, user will not be able to place a new receive request till the active
 * reception is complete. This API can stop the progressing reception to make
 * a new receive request.
 * <BR>
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 * //Description:
 * //Transmits the string "Infineon DAVE application" to the slave.
 * //Starts to receive data from slave, checks if the first byte is 0x55.
 * //If so, aborts the reception and retransmits 0x55 to slave.
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   uint8_t Send_Data[] = "Infineon DAVE application.";
 *   uint8_t Rec_Data[64];
 *
 *   status = DAVE_Init();    // SPI_MASTER_Init() is called from DAVE_Init()
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     SPI_MASTER_Transmit(&SPI_MASTER_0, Send_Data, sizeof(Send_Data));
 *     while(SPI_MASTER_0.runtime->tx_busy);
 *
 *     SPI_MASTER_Receive(&SPI_MASTER_0, Rec_Data, 15U);
 *
 *     if(SPI_MASTER_0.runtime->rx_data[0] == 0x55)
 *     {
 *       SPI_MASTER_AbortReceive(&SPI_MASTER_0);
 *       SPI_MASTER_Transmit(&SPI_MASTER_0, Rec_Data, 1);
 *     }
 *   }
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 * }
 * @endcode
 *
 */
SPI_MASTER_STATUS_t SPI_MASTER_AbortReceive(const SPI_MASTER_t *const handle);

/**
 *@}
 */
#include "spi_master_extern.h"

#ifdef __cplusplus
}
#endif

#endif /* SPI_MASTER_H */
